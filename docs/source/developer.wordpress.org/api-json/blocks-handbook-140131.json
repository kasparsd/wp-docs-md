{
    "id": 140131,
    "date": "2022-02-09T01:54:48",
    "date_gmt": "2022-02-09T01:54:48",
    "guid": {
        "rendered": "https://developer.wordpress.org/block-editor/how-to-guides/data-basics/2-building-a-list-of-pages/"
    },
    "modified": "2025-04-17T03:15:31",
    "modified_gmt": "2025-04-17T03:15:31",
    "slug": "2-building-a-list-of-pages",
    "status": "publish",
    "type": "blocks-handbook",
    "link": "https://developer.wordpress.org/block-editor/how-to-guides/data-basics/2-building-a-list-of-pages/",
    "title": {
        "rendered": "Building a list of pages"
    },
    "content": {
        "rendered": "<p>In this part, we will build a filterable list of all WordPress pages. This is what the app will look like at the end of this section:</p>\n<p><img data-recalc-dims=\"1\" decoding=\"async\" src=\"https://i0.wp.com/raw.githubusercontent.com/WordPress/gutenberg/HEAD/docs/how-to-guides/data-basics/media/list-of-pages/part1-finished.jpg?ssl=1\" alt=\"\" /></p>\n<p>Let\u2019s see how we can get there step by step.</p>\n<h2>Step 1: Build the PagesList component</h2>\n<p>Let\u2019s start by building a minimal React component to display the list of pages:</p>\n<pre><code class=\"language-js\">function MyFirstApp() {\n    const pages = [{ id: 'mock', title: 'Sample page' }]\n    return &lt;PagesList pages={ pages }/&gt;;\n}\n\nfunction PagesList( { pages } ) {\n    return (\n        &lt;ul&gt;\n            { pages?.map( page =&gt; (\n                &lt;li key={ page.id }&gt;\n                    { page.title }\n                &lt;/li&gt;\n            ) ) }\n        &lt;/ul&gt;\n    );\n}\n</code></pre>\n<p>Note that this component does not fetch any data yet, only presents the hardcoded list of pages. When you refresh the page, you should see the following:</p>\n<p><img data-recalc-dims=\"1\" decoding=\"async\" src=\"https://i0.wp.com/raw.githubusercontent.com/WordPress/gutenberg/HEAD/docs/how-to-guides/data-basics/media/list-of-pages/simple-list.jpg?ssl=1\" alt=\"\" /></p>\n<h2>Step 2: Fetch the data</h2>\n<p>The hard-coded sample page isn\u2019t very useful. We want to display your actual WordPress pages so let\u2019s fetch the actual list of pages from the <a href=\"https://developer.wordpress.org/rest-api/\">WordPress REST API</a>.</p>\n<p>Before we start, let\u2019s confirm we actually have some pages to fetch. Within WPAdmin, Navigate to Pages using the sidebar menu and ensure it shows at least four or five Pages:</p>\n<p><img data-recalc-dims=\"1\" decoding=\"async\" src=\"https://i0.wp.com/raw.githubusercontent.com/WordPress/gutenberg/HEAD/docs/how-to-guides/data-basics/media/list-of-pages/pages-list.jpg?ssl=1\" alt=\"\" /></p>\n<p>If it doesn\u2019t, go ahead and create a few pages \u2013 you can use the same titles as on the screenshot above. Be sure to <em>publish</em> and not just <em>save</em> them.</p>\n<p>Now that we have the data to work with, let\u2019s dive into the code. We will take advantage of the <a href=\"https://github.com/WordPress/gutenberg/tree/trunk/packages/core-data\"><code>@wordpress/core-data</code></a> package which provides resolvers, selectors, and actions to work with the WordPress core API. <code>@wordpress/core-data</code> builds on top of the <a href=\"https://github.com/WordPress/gutenberg/tree/trunk/packages/data\"><code>@wordpress/data</code></a> package.</p>\n<p>To fetch the list of pages, we will use the <a href=\"https://developer.wordpress.org/block-editor/reference-guides/data/data-core/#getentityrecords\"><code>getEntityRecords</code></a> selector. In broad strokes, it will issue the correct API request, cache the results, and return the list of the records we need. Here\u2019s how to use it:</p>\n<pre><code class=\"language-js\">wp.data.select( 'core' ).getEntityRecords( 'postType', 'page' )\n</code></pre>\n<p>If you run that following snippet in your browser\u2019s dev tools, you will see it returns <code>null</code>. Why? The pages are only requested by the <code>getEntityRecords</code> resolver after first running the <em>selector</em>. If you wait a moment and re-run it, it will return the list of all pages.</p>\n<p><em>Note: To run this type of command directly make sure your browser is displaying an instance of the block editor (any page will do). Otherwise the <code>select( 'core' )</code> function won&#8217;t be available, and you&#8217;ll get an error.</em></p>\n<p>Similarly, the <code>MyFirstApp</code> component needs to re-run the selector once the data is available. That\u2019s exactly what the <code>useSelect</code> hook does:</p>\n<pre><code class=\"language-js\">import { useSelect } from '@wordpress/data';\nimport { store as coreDataStore } from '@wordpress/core-data';\n\nfunction MyFirstApp() {\n    const pages = useSelect(\n        select =&gt;\n            select( coreDataStore ).getEntityRecords( 'postType', 'page' ),\n        []\n    );\n    // ...\n}\n\nfunction PagesList({ pages }) {\n    // ...\n    &lt;li key={page.id}&gt;\n        {page.title.rendered}\n    &lt;/li&gt;\n    // ...\n}\n</code></pre>\n<p>Note that we use an <code>import</code> statement inside index.js. This enables the plugin to automatically load the dependencies using <code>wp_enqueue_script</code>. Any references to <code>coreDataStore</code> are compiled to the same <code>wp.data</code> reference we use in browser&#8217;s devtools.</p>\n<p><code>useSelect</code> takes two arguments: a callback and dependencies. In broad strokes, it re-runs the callback whenever either the dependencies or the underlying data store changes. You can learn more about <a href=\"https://developer.wordpress.org/block-editor/reference-guide/packages/packages-data/#useselect\">useSelect</a> in the <a href=\"https://developer.wordpress.org/block-editor/reference-guide/packages/packages-data/#useselect\">data module documentation</a>.</p>\n<p>Putting it together, we get the following code:</p>\n<pre><code class=\"language-js\">import { useSelect } from '@wordpress/data';\nimport { store as coreDataStore } from '@wordpress/core-data';\nimport { decodeEntities } from '@wordpress/html-entities';\n\nfunction MyFirstApp() {\n    const pages = useSelect(\n        select =&gt;\n            select( coreDataStore ).getEntityRecords( 'postType', 'page' ),\n        []\n    );\n    return &lt;PagesList pages={ pages }/&gt;;\n}\n\nfunction PagesList( { pages } ) {\n    return (\n        &lt;ul&gt;\n            { pages?.map( page =&gt; (\n                &lt;li key={ page.id }&gt;\n                    { decodeEntities( page.title.rendered ) }\n                &lt;/li&gt;\n            ) ) }\n        &lt;/ul&gt;\n    )\n}\n</code></pre>\n<p>Note that post title may contain HTML entities like <code>&amp;aacute;</code>, so we need to use the <a href=\"https://developer.wordpress.org/block-editor/reference-guides/packages/packages-html-entities/\"><code>decodeEntities</code></a> function to replace them with the symbols they represent like <code>\u00e1</code>.</p>\n<p>Refreshing the page should display a list similar to this one:</p>\n<p><img data-recalc-dims=\"1\" decoding=\"async\" src=\"https://i0.wp.com/raw.githubusercontent.com/WordPress/gutenberg/HEAD/docs/how-to-guides/data-basics/media/list-of-pages/fetch-the-data.jpg?ssl=1\" alt=\"\" /></p>\n<h2>Step 3: Turn it into a table</h2>\n<pre><code class=\"language-js\">function PagesList( { pages } ) {\n    return (\n        &lt;table className=\"wp-list-table widefat fixed striped table-view-list\"&gt;\n            &lt;thead&gt;\n                &lt;tr&gt;\n                    &lt;th&gt;Title&lt;/th&gt;\n                &lt;/tr&gt;\n            &lt;/thead&gt;\n            &lt;tbody&gt;\n                { pages?.map( page =&gt; (\n                    &lt;tr key={ page.id }&gt;\n                        &lt;td&gt;{ decodeEntities( page.title.rendered ) }&lt;/td&gt;\n                    &lt;/tr&gt;\n                ) ) }\n            &lt;/tbody&gt;\n        &lt;/table&gt;\n    );\n}\n</code></pre>\n<p><img data-recalc-dims=\"1\" decoding=\"async\" src=\"https://i0.wp.com/raw.githubusercontent.com/WordPress/gutenberg/HEAD/docs/how-to-guides/data-basics/media/list-of-pages/make-a-table.jpg?ssl=1\" alt=\"\" /></p>\n<h2>Step 4: Add a search box</h2>\n<p>The list of pages is short for now; however, the longer it grows, the harder it is to work with. WordPress admins typically solves this problem with a search box \u2013 let\u2019s implement one too!</p>\n<p>Let\u2019s start by adding a search field:</p>\n<pre><code class=\"language-js\">import { useState } from 'react';\nimport { SearchControl } from '@wordpress/components';\n\nfunction MyFirstApp() {\n    const [searchTerm, setSearchTerm] = useState( &apos;&apos; );\n    // ...\n    return (\n        &lt;div&gt;\n            &lt;SearchControl\n                onChange={ setSearchTerm }\n                value={ searchTerm }\n            /&gt;\n            {/* ... */ }\n        &lt;/div&gt;\n    )\n}\n</code></pre>\n<p>Note that instead of using an <code>input</code> tag, we took advantage of the <a href=\"https://developer.wordpress.org/block-editor/reference-guides/components/search-control/\">SearchControl</a> component. This is what it looks like:</p>\n<p><img data-recalc-dims=\"1\" decoding=\"async\" src=\"https://i0.wp.com/raw.githubusercontent.com/WordPress/gutenberg/HEAD/docs/how-to-guides/data-basics/media/list-of-pages/filter-field.jpg?ssl=1\" alt=\"\" /></p>\n<p>The field starts empty, and the contents are stored in the <code>searchTerm</code> state value. If you aren\u2019t familiar with the <a href=\"https://react.dev/reference/react/useState\">useState</a> hook, you can learn more in <a href=\"https://react.dev/reference/react/useState\">React\u2019s documentation</a>.</p>\n<p>We can now request only the pages matching the <code>searchTerm</code>.</p>\n<p>After checking with the <a href=\"https://developer.wordpress.org/rest-api/reference/pages/\">WordPress API documentation</a>, we see that the <a href=\"https://developer.wordpress.org/rest-api/reference/pages/\">/wp/v2/pages</a> endpoint accepts a <code>search</code> query parameter and uses it to  <em>limit results to those matching a string</em>. But how can we use it? We can pass custom query parameters as the third argument to <code>getEntityRecords</code> as below:</p>\n<pre><code class=\"language-js\">wp.data.select( 'core' ).getEntityRecords( 'postType', 'page', { search: 'home' } )\n</code></pre>\n<p>Running that snippet in your browser\u2019s dev tools will trigger a request to <code>/wp/v2/pages?search=home</code> instead of just <code>/wp/v2/pages</code>.</p>\n<p>Let\u2019s mirror this in our <code>useSelect</code> call as follows:</p>\n<pre><code class=\"language-js\">import { useSelect } from '@wordpress/data';\nimport { store as coreDataStore } from '@wordpress/core-data';\n\nfunction MyFirstApp() {\n    // ...\n    const { pages } = useSelect( select =&gt; {\n        const query = {};\n        if ( searchTerm ) {\n            query.search = searchTerm;\n        }\n        return {\n            pages: select( coreDataStore ).getEntityRecords( 'postType', 'page', query )\n        }\n    }, [searchTerm] );\n\n    // ...\n}\n</code></pre>\n<p>The <code>searchTerm</code> is now used as a <code>search</code> query parameter when provided. Note that <code>searchTerm</code> is also specified inside the list of <code>useSelect</code> dependencies to make sure <code>getEntityRecords</code> is re-run when the <code>searchTerm</code> changes.</p>\n<p>Finally, here\u2019s how <code>MyFirstApp</code> looks once we wire it all together:</p>\n<pre><code class=\"language-js\">import { useState } from 'react';\nimport { createRoot } from 'react-dom';\nimport { SearchControl } from '@wordpress/components';\nimport { useSelect } from '@wordpress/data';\nimport { store as coreDataStore } from '@wordpress/core-data';\n\nfunction MyFirstApp() {\n    const [searchTerm, setSearchTerm] = useState( &apos;&apos; );\n    const pages = useSelect( select =&gt; {\n        const query = {};\n        if ( searchTerm ) {\n            query.search = searchTerm;\n        }\n        return select( coreDataStore ).getEntityRecords( 'postType', 'page', query );\n    }, [searchTerm] );\n\n    return (\n        &lt;div&gt;\n            &lt;SearchControl\n                onChange={ setSearchTerm }\n                value={ searchTerm }\n            /&gt;\n            &lt;PagesList pages={ pages }/&gt;\n        &lt;/div&gt;\n    )\n}\n</code></pre>\n<p>Voila! We can now filter the results:</p>\n<p><img data-recalc-dims=\"1\" decoding=\"async\" src=\"https://i0.wp.com/raw.githubusercontent.com/WordPress/gutenberg/HEAD/docs/how-to-guides/data-basics/media/list-of-pages/filter.jpg?ssl=1\" alt=\"\" /></p>\n<h3>Using core-data instead vs calling the API directly</h3>\n<p>Let\u2019s take a pause for a moment to consider the downsides of an alternative approach we could have taken &#8211; working with the API directly. Imagine we sent the API requests directly:</p>\n<pre><code class=\"language-js\">import apiFetch from '@wordpress/api-fetch';\nfunction MyFirstApp() {\n    // ...\n    const [pages, setPages] = useState( [] );\n    useEffect( () =&gt; {\n        const url = '/wp-json/wp/v2/pages?search=' + searchTerm;\n        apiFetch( { url } )\n            .then( setPages )\n    }, [searchTerm] );\n    // ...\n}\n</code></pre>\n<p>Working outside of core-data, we would need to solve two problems here.</p>\n<p>Firstly, out-of-order updates. Searching for \u201eAbout\u201d would trigger five API requests filtering for <code>A</code>, <code>Ab</code>, <code>Abo</code>, <code>Abou</code>, and <code>About</code>. These requests could finish in a different order than they started. It is possible that <em>search=A</em> would resolve after _ search=About_ and thus we\u2019d display the wrong data.</p>\n<p>Gutenberg data helps by handling the asynchronous part behind the scenes. <code>useSelect</code> remembers the most recent call and returns only the data we expect.</p>\n<p>Secondly, every keystroke would trigger an API request. If you typed <code>About</code>, deleted it, and retyped it, it would issue 10 requests in total even though we could reuse the data.</p>\n<p>Gutenberg data helps by caching the responses to API requests triggered by <code>getEntityRecords()</code>  and reuses them on subsequent calls. This is especially important when other components rely on the same entity records.</p>\n<p>All in all, the utilities built into core-data are designed to solve the typical problems so that you can focus on your application instead.</p>\n<h2>Step 5: Loading Indicator</h2>\n<p>There is one problem with our search feature. We can\u2019t be quite sure whether it\u2019s still searching or showing no results:</p>\n<p><img data-recalc-dims=\"1\" decoding=\"async\" src=\"https://i0.wp.com/raw.githubusercontent.com/WordPress/gutenberg/HEAD/docs/how-to-guides/data-basics/media/list-of-pages/unclear-status.jpg?ssl=1\" alt=\"\" /></p>\n<p>A few messages like  <em>Loading\u2026</em> or <em>No results</em> would clear it up. Let\u2019s implement them! First,  <code>PagesList</code> has to be aware of the current status:</p>\n<pre><code class=\"language-js\">import { SearchControl, Spinner } from '@wordpress/components';\nfunction PagesList( { hasResolved, pages } ) {\n    if ( !hasResolved ) {\n        return &lt;Spinner/&gt;\n    }\n    if ( !pages?.length ) {\n        return &lt;div&gt;No results&lt;/div&gt;\n    }\n    // ...\n}\n\nfunction MyFirstApp() {\n    // ...\n\n    return (\n        &lt;div&gt;\n            // ...\n            &lt;PagesList hasResolved={ hasResolved } pages={ pages }/&gt;\n        &lt;/div&gt;\n    )\n}\n</code></pre>\n<p>Note that instead of building a custom loading indicator, we took advantage of the <a href=\"https://developer.wordpress.org/block-editor/reference-guides/components/spinner/\">Spinner</a> component.</p>\n<p>We still need to know whether the pages selector <code>hasResolved</code> or not. We can find out using the  <code>hasFinishedResolution</code> selector:</p>\n<p><code>wp.data.select('core').hasFinishedResolution( 'getEntityRecords', [ 'postType', 'page', { search: 'home' } ] )</code></p>\n<p>It takes the name of the selector and the <em>exact same arguments you passed to that selector</em> and returns either <code>true</code> if the data was already loaded or <code>false</code> if we\u2019re still waiting. Let\u2019s add it to <code>useSelect</code>:</p>\n<pre><code class=\"language-js\">import { useSelect } from '@wordpress/data';\nimport { store as coreDataStore } from '@wordpress/core-data';\n\nfunction MyFirstApp() {\n    // ...\n    const { pages, hasResolved } = useSelect( select =&gt; {\n        // ...\n        return {\n            pages: select( coreDataStore ).getEntityRecords( 'postType', 'page', query ),\n            hasResolved:\n                select( coreDataStore ).hasFinishedResolution( 'getEntityRecords', ['postType', 'page', query] ),\n        }\n    }, [searchTerm] );\n\n    // ...\n}\n</code></pre>\n<p>There is just one last problem. It is easy to make a typo and end up passing different arguments to <code>getEntityRecords</code> and <code>hasFinishedResolution</code>. It is critical that they are identical. We can remove this risk by storing the arguments in a variable:</p>\n<pre><code class=\"language-js\">import { useSelect } from '@wordpress/data';\nimport { store as coreDataStore } from '@wordpress/core-data';\nfunction MyFirstApp() {\n    // ...\n    const { pages, hasResolved } = useSelect( select =&gt; {\n        // ...\n        const selectorArgs = [ 'postType', 'page', query ];\n        return {\n            pages: select( coreDataStore ).getEntityRecords( ...selectorArgs ),\n            hasResolved:\n                select( coreDataStore ).hasFinishedResolution( 'getEntityRecords', selectorArgs ),\n        }\n    }, [searchTerm] );\n\n    // ...\n}\n</code></pre>\n<p>And voil\u00e0! That&#8217;s it.</p>\n<h3>Wiring it all together</h3>\n<p>All the pieces are in place, great! Here\u2019s the complete JavaScript code of our app:</p>\n<pre><code class=\"language-js\">import { useState } from 'react';\nimport { createRoot } from 'react-dom';\nimport { SearchControl, Spinner } from '@wordpress/components';\nimport { useSelect } from '@wordpress/data';\nimport { store as coreDataStore } from '@wordpress/core-data';\nimport { decodeEntities } from '@wordpress/html-entities';\nimport './style.css';\n\nfunction MyFirstApp() {\n    const [ searchTerm, setSearchTerm ] = useState( &apos;&apos; );\n    const { pages, hasResolved } = useSelect(\n        ( select ) =&gt; {\n            const query = {};\n            if ( searchTerm ) {\n                query.search = searchTerm;\n            }\n            const selectorArgs = [ 'postType', 'page', query ];\n            return {\n                pages: select( coreDataStore ).getEntityRecords(\n                    ...selectorArgs\n                ),\n                hasResolved: select( coreDataStore ).hasFinishedResolution(\n                    'getEntityRecords',\n                    selectorArgs\n                ),\n            };\n        },\n        [ searchTerm ]\n    );\n\n    return (\n        &lt;div&gt;\n            &lt;SearchControl onChange={ setSearchTerm } value={ searchTerm } /&gt;\n            &lt;PagesList hasResolved={ hasResolved } pages={ pages } /&gt;\n        &lt;/div&gt;\n    );\n}\n\nfunction PagesList( { hasResolved, pages } ) {\n    if ( ! hasResolved ) {\n        return &lt;Spinner /&gt;;\n    }\n    if ( ! pages?.length ) {\n        return &lt;div&gt;No results&lt;/div&gt;;\n    }\n\n    return (\n        &lt;table className=\"wp-list-table widefat fixed striped table-view-list\"&gt;\n            &lt;thead&gt;\n                &lt;tr&gt;\n                    &lt;td&gt;Title&lt;/td&gt;\n                &lt;/tr&gt;\n            &lt;/thead&gt;\n            &lt;tbody&gt;\n                { pages?.map( ( page ) =&gt; (\n                    &lt;tr key={ page.id }&gt;\n                        &lt;td&gt;{ decodeEntities( page.title.rendered ) }&lt;/td&gt;\n                    &lt;/tr&gt;\n                ) ) }\n            &lt;/tbody&gt;\n        &lt;/table&gt;\n    );\n}\n\nconst root = createRoot(\n    document.querySelector( '#my-first-gutenberg-app' )\n);\nwindow.addEventListener(\n    'load',\n    function () {\n        root.render(\n            &lt;MyFirstApp /&gt;\n        );\n    },\n    false\n);\n</code></pre>\n<p>All that\u2019s left is to refresh the page and enjoy the brand new status indicator:</p>\n<p><img data-recalc-dims=\"1\" decoding=\"async\" src=\"https://i0.wp.com/raw.githubusercontent.com/WordPress/gutenberg/HEAD/docs/how-to-guides/data-basics/media/list-of-pages/indicator.jpg?ssl=1\" alt=\"\" /><br />\n<img data-recalc-dims=\"1\" decoding=\"async\" src=\"https://i0.wp.com/raw.githubusercontent.com/WordPress/gutenberg/HEAD/docs/how-to-guides/data-basics/media/list-of-pages/no-results.jpg?ssl=1\" alt=\"\" /></p>\n<h2>What&#8217;s next?</h2>\n<ul>\n<li><strong>Previous part:</strong> <a href=\"https://developer.wordpress.org/block-editor/how-to-guides/data-basics/1-data-basics-setup/\">Setup</a></li>\n<li><strong>Next part:</strong> <a href=\"https://developer.wordpress.org/block-editor/how-to-guides/data-basics/3-building-an-edit-form/\">Building an edit form</a></li>\n<li>(optional) Review the <a href=\"https://github.com/WordPress/block-development-examples/tree/trunk/plugins/data-basics-59c8f8\">finished app</a> in the block-development-examples repository</li>\n</ul>\n",
        "protected": false
    },
    "author": 0,
    "featured_media": 0,
    "parent": 140129,
    "menu_order": 31,
    "template": "",
    "meta": {
        "footnotes": ""
    },
    "class_list": [
        "post-140131",
        "blocks-handbook",
        "type-blocks-handbook",
        "status-publish",
        "hentry",
        "type-handbook"
    ],
    "revision_note": "",
    "jetpack_sharing_enabled": true,
    "_links": {
        "self": [
            {
                "href": "https://developer.wordpress.org/wp-json/wp/v2/blocks-handbook/140131",
                "targetHints": {
                    "allow": [
                        "GET"
                    ]
                }
            }
        ],
        "collection": [
            {
                "href": "https://developer.wordpress.org/wp-json/wp/v2/blocks-handbook"
            }
        ],
        "about": [
            {
                "href": "https://developer.wordpress.org/wp-json/wp/v2/types/blocks-handbook"
            }
        ],
        "version-history": [
            {
                "count": 13,
                "href": "https://developer.wordpress.org/wp-json/wp/v2/blocks-handbook/140131/revisions"
            }
        ],
        "predecessor-version": [
            {
                "id": 157548,
                "href": "https://developer.wordpress.org/wp-json/wp/v2/blocks-handbook/140131/revisions/157548"
            }
        ],
        "up": [
            {
                "embeddable": true,
                "href": "https://developer.wordpress.org/wp-json/wp/v2/blocks-handbook/140129"
            }
        ],
        "wp:attachment": [
            {
                "href": "https://developer.wordpress.org/wp-json/wp/v2/media?parent=140131"
            }
        ],
        "curies": [
            {
                "name": "wp",
                "href": "https://api.w.org/{rel}",
                "templated": true
            }
        ]
    }
}