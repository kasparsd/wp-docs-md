{
    "id": 137774,
    "date": "2021-12-07T19:39:49",
    "date_gmt": "2021-12-07T19:39:49",
    "guid": {
        "rendered": "https://developer.wordpress.org/block-editor/contributors/code/react-native/integration-test-guide/"
    },
    "modified": "2025-01-07T18:34:08",
    "modified_gmt": "2025-01-07T18:34:08",
    "slug": "integration-test-guide",
    "status": "publish",
    "type": "blocks-handbook",
    "link": "https://developer.wordpress.org/block-editor/contributors/code/react-native/integration-test-guide/",
    "title": {
        "rendered": "React Native Integration Test Guide"
    },
    "content": {
        "rendered": "<h2>What\u2019s an integration test?</h2>\n<p>Integration testing is defined as a type of testing where different parts are tested as a group. In our case, the parts that we want to test are the different components that are required to be rendered for a specific block or editor logic. In the end, they are very similar to unit tests as they are run with the same command using the Jest library. The main difference is that for the integration tests, we\u2019re going to use a specific library <a href=\"https://testing-library.com/docs/react-native-testing-library/intro/\"><code>react-native-testing-library</code></a> for testing how the editor renders the different components.</p>\n<h2>Anatomy of an integration test</h2>\n<p>A test can be structured with the following parts:</p>\n<ul>\n<li><a href=\"#setup\">Setup</a></li>\n<li><a href=\"#rendering\">Rendering</a></li>\n<li><a href=\"#query-elements\">Query elements</a></li>\n<li><a href=\"#fire-events\">Fire events</a></li>\n<li><a href=\"#expect-correct-element-behaviour\">Expect correct element behaviour</a></li>\n<li><a href=\"#cleanup\">Cleanup</a></li>\n</ul>\n<p>We also include examples of common tasks as well as tips in the following sections:</p>\n<ul>\n<li><a href=\"#helpers\">Helpers</a></li>\n<li><a href=\"#common-flows\">Common flows</a></li>\n<li><a href=\"#tools\">Tools</a></li>\n<li><a href=\"#common-pitfalls-and-caveats\">Common pitfalls and caveats</a></li>\n</ul>\n<h2>Setup</h2>\n<p>This part usually is covered by using the Jest callbacks <code>beforeAll</code> and <code>beforeEach</code>, the purpose is to prepare everything that the test might require like registering blocks or mocking parts of the logic.</p>\n<p>Here is an example of a common pattern if we expect all core blocks to be available:</p>\n<pre><code class=\"language-js\">beforeAll( () =&gt; {\n    // Register all core blocks\n    registerCoreBlocks();\n} );\n</code></pre>\n<h2>Rendering</h2>\n<p>Before introducing the testing logic, we have to render the components that we want to test on. Depending on if we want to use the scoped component or entire editor approach, this part will be different.</p>\n<h3>Using the Scoped Component approach</h3>\n<p>Here is an example of rendering the Cover block (extracted from <a href=\"https://github.com/WordPress/gutenberg/blob/86cd187873984f80ddeeec3e82454b486dd1860f/packages/block-library/src/cover/test/edit.native.js#L82-L91\">this code</a>):</p>\n<pre><code class=\"language-js\">// This import points to the index file of the block\nimport { metadata, settings, name } from '../index';\n\n...\n\nconst setAttributes = jest.fn();\nconst attributes = {\n    backgroundType: IMAGE_BACKGROUND_TYPE,\n    focalPoint: { x: '0.25', y: '0.75' },\n    hasParallax: false,\n    overlayColor: { color: '#000000' },\n    url: 'mock-url',\n};\n\n...\n\n// Simplified tree to render Cover edit within slot\nconst CoverEdit = ( props ) =&gt; (\n    &lt;SlotFillProvider&gt;\n        &lt;BlockEdit isSelected name={ name } clientId={ 0 } { ...props } /&gt;\n        &lt;BottomSheetSettings isVisible /&gt;\n    &lt;/SlotFillProvider&gt;\n);\n\nconst { getByText, findByText } = render(\n    &lt;CoverEdit\n        attributes={ {\n            ...attributes,\n            url: undefined,\n            backgroundType: undefined,\n        } }\n        setAttributes={ setAttributes }\n    /&gt;\n);\n</code></pre>\n<h3>Using the Entire Editor approach</h3>\n<p>Here is an example of rendering the Buttons block (extracted from <a href=\"https://github.com/WordPress/gutenberg/blob/9201906891a68ca305daf7f8b6cd006e2b26291e/packages/block-library/src/buttons/test/edit.native.js#L32-L39\">this code</a>):</p>\n<pre><code class=\"language-js\">const initialHtml = `&lt;!-- wp:buttons --&gt;\n&lt;div class=\"wp-block-buttons\"&gt;&lt;!-- wp:button {\"style\":{\"border\":{\"radius\":\"5px\"}}} --&gt;\n&lt;div class=\"wp-block-button\"&gt;&lt;a class=\"wp-block-button__link\" style=\"border-radius:5px\" &gt;Hello&lt;/a&gt;&lt;/div&gt;\n&lt;!-- /wp:button --&gt;&lt;/div&gt;\n&lt;!-- /wp:buttons --&gt;`;\nconst { getByLabelText } = initializeEditor( {\n    initialHtml,\n} );\n</code></pre>\n<h2>Query elements</h2>\n<p>Once the components are rendered, it\u2019s time to query them. An important note about this topic is that we should test from the user\u2019s perspective, this means that ideally we should query by elements that the user has access to like texts or accessibility labels.</p>\n<p>When querying we should follow this priority order:</p>\n<ol>\n<li><code>getByText</code>: querying by text is the closest flow we can do from the user\u2019s perspective, as text is the visual clue for them to identify elements.</li>\n<li><code>getByLabelText</code>: in some cases, we want to query elements that don\u2019t provide text so in this case we can fallback to the accessibility label.</li>\n<li><code>getByTestId</code>: if none of the previous options fit and/or we don\u2019t have any visual element that we can rely upon, we have to fallback to a specific test id, which can be defined using the <code>testID</code> attribute (see <a href=\"https://github.com/WordPress/gutenberg/blob/e5b387b19ffc50555f52ea5f0b415ab846896def/packages/block-editor/src/components/block-types-list/index.native.js#L80\">here</a> for an example).</li>\n</ol>\n<p>Here are some examples:</p>\n<pre><code class=\"language-js\">const mediaLibraryButton = getByText( 'WordPress Media Library' );\n</code></pre>\n<pre><code class=\"language-js\">const missingBlock = getByLabelText( /Unsupported Block\\. Row 1/ );\n</code></pre>\n<pre><code class=\"language-js\">const radiusSlider = getByTestId( 'Slider Border Radius' );\n</code></pre>\n<p>Note that either a plain string or a regular expression can be passed into these queries. A regular expression is best for querying part of a string (e.g. any element whose accessibility label contains <code>Unsupported Block. Row 1</code>). Note that special characters such as <code>.</code> need to be escaped.</p>\n<h3>Use of <code>find</code> queries</h3>\n<p>After rendering the components or firing an event, side effects might happen due to potential state updates so the element we\u2019re looking for might not be yet rendered. In this case, we would need to wait for the element to be available and for this purpose, we can use the <code>find*</code> versions of query functions, which internally use <code>waitFor</code> and periodically check whether the element appeared or not.</p>\n<p>Here are some examples:</p>\n<pre><code class=\"language-js\">const mediaLibraryButton = await findByText( 'WordPress Media Library' );\n</code></pre>\n<pre><code class=\"language-js\">const missingBlock = await findByLabelText( /Unsupported Block\\. Row 1/ );\n</code></pre>\n<pre><code class=\"language-js\">const radiusSlider = await findByTestId( 'Slider Border Radius' );\n</code></pre>\n<p>In most cases we\u2019ll use the <code>find*</code> functions, but it\u2019s important to note that it should be restricted to those queries that actually require waiting for the element to be available.</p>\n<h3><code>within</code> queries</h3>\n<p>It\u2019s also possible to query elements contained in other elements via the <code>within</code> function, here is an example:</p>\n<pre><code class=\"language-js\">const missingBlock = await findByLabelText( /Unsupported Block\\. Row 1/ );\nconst translatedTableTitle = within( missingBlock ).getByText( 'Tabla' );\n</code></pre>\n<h2>Fire events</h2>\n<p>As important as querying an element is to trigger events to simulate the user interaction, for this purpose we can use the <code>fireEvent</code> function (<a href=\"https://callstack.github.io/react-native-testing-library/docs/api#fireevent\">documentation</a>).</p>\n<p>Here is an example of a press event:</p>\n<p><strong>Press event:</strong></p>\n<pre><code class=\"language-js\">fireEvent.press( settingsButton );\n</code></pre>\n<p>We can also trigger any type of event, including custom events, in the following example you can see how we trigger the <code>onValueChange</code> event (<a href=\"https://github.com/WordPress/gutenberg/blob/520cbd9d2af4bbc275d388edf92a6cadb685de56/packages/components/src/mobile/bottom-sheet/range-cell.native.js#L227\">code reference</a>) for the Slider component:</p>\n<p><strong>Custom event \u2013 onValueChange:</strong></p>\n<pre><code class=\"language-js\">fireEvent( heightSlider, 'valueChange', '50' );\n</code></pre>\n<h2>Expect correct element behaviour</h2>\n<p>After querying elements and firing events, we must verify that the logic works as expected. For this purpose we can use the same <code>expect</code> function from Jest that we use in unit tests. It is recommended to use the custom <code>toBeVisible</code> matcher to ensure the element is defined, is a valid React element, and visible.</p>\n<p>Here is an example:</p>\n<pre><code class=\"language-js\">const translatedTableTitle = within( missingBlock ).getByText( 'Tabla' );\nexpect( translatedTableTitle ).toBeVisible();\n</code></pre>\n<p>Additionally when rendering the entire editor, we can also verify if the HTML output is what we expect:</p>\n<pre><code class=\"language-js\">expect( getEditorHtml() ).toBe(\n    '&lt;!-- wp:spacer {\"height\":50} --&gt;\\n&lt;div style=\"height:50px\" aria-hidden=\"true\" class=\"wp-block-spacer\"&gt;&lt;/div&gt;\\n&lt;!-- /wp:spacer --&gt;'\n);\n</code></pre>\n<h2>Cleanup</h2>\n<p>And finally, we have to clean up any potential modifications we\u2019ve made that could affect the following tests. Here is an example of a typical cleanup after registering blocks that implies unregistering all blocks:</p>\n<pre><code class=\"language-js\">afterAll( () =&gt; {\n    // Clean up registered blocks\n    getBlockTypes().forEach( ( block ) =&gt; {\n        unregisterBlockType( block.name );\n    } );\n} );\n</code></pre>\n<h2>Helpers</h2>\n<p>In the spirit of making easier writing integration tests for the native version, you can find a list of helper functions in <a href=\"https://github.com/WordPress/gutenberg/blob/HEAD/test/native/integration-test-helpers/README.md\">this README</a>.</p>\n<h2>Common flows</h2>\n<h3>Query a block</h3>\n<p>A common way to query a block is by its accessibility label, here is an example:</p>\n<pre><code class=\"language-js\">const spacerBlock = await waitFor( () =&gt;\n    getByLabelText( /Spacer Block\\. Row 1/ )\n);\n</code></pre>\n<p>For further information about the accessibility label of a block, you can check the code of the <a href=\"https://github.com/WordPress/gutenberg/blob/520cbd9d2af4bbc275d388edf92a6cadb685de56/packages/blocks/src/api/utils.js#L167-L234\">function <code>getAccessibleBlockLabel</code></a>.</p>\n<h3>Add a block</h3>\n<p>Here is an example of how to insert a Paragraph block:</p>\n<pre><code class=\"language-js\">// Open the inserter menu\nfireEvent.press( await findByLabelText( 'Add block' ) );\n\nconst blockList = getByTestId( 'InserterUI-Blocks' );\n// onScroll event used to force the FlatList to render all items\nfireEvent.scroll( blockList, {\n    nativeEvent: {\n        contentOffset: { y: 0, x: 0 },\n        contentSize: { width: 100, height: 100 },\n        layoutMeasurement: { width: 100, height: 100 },\n    },\n} );\n\n// Insert a Paragraph block\nfireEvent.press( await findByText( `Paragraph` ) );\n</code></pre>\n<h3>Open block settings</h3>\n<p>The block settings can be accessed by tapping the &#8220;Open Settings&#8221; button after selecting the block, here is an example:</p>\n<pre><code class=\"language-js\">fireEvent.press( block );\n\nconst settingsButton = await findByLabelText( 'Open Settings' );\nfireEvent.press( settingsButton );\n</code></pre>\n<h4>Using the Scoped Component approach</h4>\n<p>When using the scoped component approach, we need first to render the <code>SlotFillProvider</code> and the <code>BottomSheetSettings</code> (note that we\u2019re passing the <code>isVisible</code> prop to force the bottom sheet to be displayed) along with the block:</p>\n<pre><code class=\"language-js\">&lt;SlotFillProvider&gt;\n    &lt;BlockEdit isSelected name={ name } clientId={ 0 } { ...props } /&gt;\n    &lt;BottomSheetSettings isVisible /&gt;\n&lt;/SlotFillProvider&gt;\n</code></pre>\n<p>See examples:</p>\n<ul>\n<li><a href=\"https://github.com/WordPress/gutenberg/blob/b403b977b029911f46247012fa2dcbc42a5aa3cf/packages/block-library/src/cover/test/edit.native.js#L37-L42\">Cover block</a></li>\n</ul>\n<h3>FlatList items</h3>\n<p>The <code>FlatList</code> component renders its items depending on the scroll position, the view and content size. This means that when rendering this component it might happen that some of the items can\u2019t be queried because they haven\u2019t been rendered yet. To address this issue we have to explicitly fire an event to make the <code>FlatList</code> render all the items.</p>\n<p>Here is an example of the FlatList used for rendering the block list in the inserter menu:</p>\n<pre><code class=\"language-js\">const blockList = getByTestId( 'InserterUI-Blocks' );\n// onScroll event used to force the FlatList to render all items\nfireEvent.scroll( blockList, {\n    nativeEvent: {\n        contentOffset: { y: 0, x: 0 },\n        contentSize: { width: 100, height: 100 },\n        layoutMeasurement: { width: 100, height: 100 },\n    },\n} );\n</code></pre>\n<h3>Sliders</h3>\n<p>Sliders found in bottom sheets should be queried using their <code>testID</code>:</p>\n<pre><code class=\"language-js\">const radiusSlider = await findByTestId( 'Slider Border Radius' );\nfireEvent( radiusSlider, 'valueChange', '30' );\n</code></pre>\n<p>Note that a slider\u2019s <code>testID</code> is &#8220;Slider &#8221; + label. So for a slider with a label of &#8220;Border Radius&#8221;, <code>testID</code> is &#8220;Slider Border Radius&#8221;.</p>\n<h3>Selecting an inner block</h3>\n<p>One caveat when adding blocks is that if they contain inner blocks, these inner blocks are not rendered. The following example shows how we can make a Buttons block render its inner Button blocks (assumes we\u2019ve already obtained a reference to the Buttons block as <code>buttonsBlock</code>):</p>\n<pre><code class=\"language-js\">const innerBlockListWrapper = await within( buttonsBlock ).findByTestId(\n    'block-list-wrapper'\n);\nfireEvent( innerBlockListWrapper, 'layout', {\n    nativeEvent: {\n        layout: {\n            width: 100,\n        },\n    },\n} );\n\nconst buttonInnerBlock = await within( buttonsBlock ).findByLabelText(\n    /Button Block\\. Row 1/\n);\nfireEvent.press( buttonInnerBlock );\n</code></pre>\n<h2>Tools</h2>\n<h3>Using the Accessibility Inspector</h3>\n<p>If you have trouble locating an element\u2019s identifier, you may wish to use Xcode\u2019s Accessibility Inspector. Most identifiers are cross-platform, so even though the tests are run on Android by default, the Accessibility Inspector can be used to find the right identifier.</p>\n<p><img data-recalc-dims=\"1\" decoding=\"async\" src=\"https://i0.wp.com/raw.githubusercontent.com/WordPress/gutenberg/trunk/docs/assets/xcode-accessibility-inspector-screenshot.png?ssl=1\" alt=\"Screenshot of the Xcode Accessibility Inspector app. The screenshot shows how to choose the correct target in the device dropdown, enable target mode, and locate accessibility labels after tapping on screen elements\" /></p>\n<h2>Common pitfalls and caveats</h2>\n<h3>False positives when omitting <code>await</code> before <code>waitFor</code> function</h3>\n<p>Omitting the <code>await</code> before a <code>waitFor</code> can lead to scenarios where tests pass but are not testing the intended behaviour. For example, if <code>toBeDefined</code> is used to assert the result of a call to <code>waitFor</code>, the assertion will pass because <code>waitFor</code> returns a value, even though it is not the <code>ReactTestInstance</code> we meant to check for. For this reason, it is recommended to use the custom matcher <code>toBeVisible</code> which guards against this type of false positive.</p>\n<h3><code>waitFor</code> timeout</h3>\n<p>The default timeout for the <code>waitFor</code> function is set to 1000 ms, so far this value is enough for all the render logic we\u2019re testing, however, if while testing we notice that an element requires more time to be rendered we should increase it.</p>\n<h3>Replace current UI unit tests</h3>\n<p>Some components already have unit tests that cover component rendering, although it\u2019s not mandatory, in these cases, it would be nice to analyze the potential migration to an integration test.</p>\n<p>In case we want to keep both, we\u2019ll add the word &#8220;integration&#8221; to the integration test file to avoid naming conflicts, here is an example: <a href=\"https://github.com/WordPress/gutenberg/blob/9201906891a68ca305daf7f8b6cd006e2b26291e/packages/block-library/src/missing/test/edit-integration.native.js\">packages/block-library/src/missing/test/edit-integration.native.js</a>.</p>\n<h3>Platform selection</h3>\n<p>By default, all tests run in Jest use the Android platform, so in case we need to test a specific behaviour related to a different platform, we would need to support platform test files.</p>\n<p>In case we only need to test logic controlled by the Platform object, we can mock the module with the following code (in this case it\u2019s changing the platform to iOS):</p>\n<pre><code class=\"language-js\">jest.mock( 'Platform', () =&gt; {\n    const Platform = jest.requireActual( 'Platform' );\n    Platform.OS = 'ios';\n    Platform.select = jest.fn().mockImplementation( ( select ) =&gt; {\n        const value = select[ Platform.OS ];\n        return ! value ? select.default : value;\n    } );\n    return Platform;\n} );\n</code></pre>\n",
        "protected": false
    },
    "author": 0,
    "featured_media": 0,
    "parent": 137772,
    "menu_order": 384,
    "template": "",
    "meta": {
        "footnotes": ""
    },
    "class_list": [
        "post-137774",
        "blocks-handbook",
        "type-blocks-handbook",
        "status-publish",
        "hentry",
        "type-handbook"
    ],
    "revision_note": "",
    "jetpack_sharing_enabled": true,
    "_links": {
        "self": [
            {
                "href": "https://developer.wordpress.org/wp-json/wp/v2/blocks-handbook/137774",
                "targetHints": {
                    "allow": [
                        "GET"
                    ]
                }
            }
        ],
        "collection": [
            {
                "href": "https://developer.wordpress.org/wp-json/wp/v2/blocks-handbook"
            }
        ],
        "about": [
            {
                "href": "https://developer.wordpress.org/wp-json/wp/v2/types/blocks-handbook"
            }
        ],
        "version-history": [
            {
                "count": 9,
                "href": "https://developer.wordpress.org/wp-json/wp/v2/blocks-handbook/137774/revisions"
            }
        ],
        "predecessor-version": [
            {
                "id": 151709,
                "href": "https://developer.wordpress.org/wp-json/wp/v2/blocks-handbook/137774/revisions/151709"
            }
        ],
        "up": [
            {
                "embeddable": true,
                "href": "https://developer.wordpress.org/wp-json/wp/v2/blocks-handbook/137772"
            }
        ],
        "wp:attachment": [
            {
                "href": "https://developer.wordpress.org/wp-json/wp/v2/media?parent=137774"
            }
        ],
        "curies": [
            {
                "name": "wp",
                "href": "https://api.w.org/{rel}",
                "templated": true
            }
        ]
    }
}