{
    "id": 140326,
    "date": "2022-03-16T16:24:47",
    "date_gmt": "2022-03-16T16:24:47",
    "guid": {
        "rendered": "https://developer.wordpress.org/block-editor/how-to-guides/data-basics/3-building-an-edit-form/"
    },
    "modified": "2024-11-18T21:54:45",
    "modified_gmt": "2024-11-18T21:54:45",
    "slug": "3-building-an-edit-form",
    "status": "publish",
    "type": "blocks-handbook",
    "link": "https://developer.wordpress.org/block-editor/how-to-guides/data-basics/3-building-an-edit-form/",
    "title": {
        "rendered": "Building an edit form"
    },
    "content": {
        "rendered": "<p>This part is about adding an <em>Edit</em> feature to our app. Here&#8217;s a glimpse of what we&#8217;re going to build:</p>\n<p><img data-recalc-dims=\"1\" decoding=\"async\" src=\"https://i0.wp.com/raw.githubusercontent.com/WordPress/gutenberg/HEAD/docs/how-to-guides/data-basics/media/edit-form/form-finished.png?ssl=1\" alt=\"\" /></p>\n<h3>Step 1: Add an <em>Edit</em> button</h3>\n<p>We can&#8217;t have an <em>Edit</em> form without an <em>Edit</em> button, so let&#8217;s start by adding one to our <code>PagesList</code> component:</p>\n<pre><code class=\"language-js\">import { Button } from '@wordpress/components';\nimport { decodeEntities } from '@wordpress/html-entities';\n\nconst PageEditButton = () =&gt; (\n    &lt;Button variant=\"primary\"&gt;\n        Edit\n    &lt;/Button&gt;\n)\n\nfunction PagesList( { hasResolved, pages } ) {\n    if ( ! hasResolved ) {\n        return &lt;Spinner /&gt;;\n    }\n    if ( ! pages?.length ) {\n        return &lt;div&gt;No results&lt;/div&gt;;\n    }\n\n    return (\n        &lt;table className=\"wp-list-table widefat fixed striped table-view-list\"&gt;\n            &lt;thead&gt;\n                &lt;tr&gt;\n                    &lt;td&gt;Title&lt;/td&gt;\n                    &lt;td style={{width: 120}}&gt;Actions&lt;/td&gt;\n                &lt;/tr&gt;\n            &lt;/thead&gt;\n            &lt;tbody&gt;\n                { pages?.map( ( page ) =&gt; (\n                    &lt;tr key={page.id}&gt;\n                        &lt;td&gt;{ decodeEntities( page.title.rendered ) }&lt;/td&gt;\n                        &lt;td&gt;\n                            &lt;PageEditButton pageId={ page.id } /&gt;\n                        &lt;/td&gt;\n                    &lt;/tr&gt;\n                ) ) }\n            &lt;/tbody&gt;\n        &lt;/table&gt;\n    );\n}\n</code></pre>\n<p>The only change in <code>PagesList</code> is the additional column labeled <em>Actions</em>:</p>\n<p><img data-recalc-dims=\"1\" decoding=\"async\" src=\"https://i0.wp.com/raw.githubusercontent.com/WordPress/gutenberg/HEAD/docs/how-to-guides/data-basics/media/edit-form/edit-button.png?ssl=1\" alt=\"\" /></p>\n<h3>Step 2: Display an <em>Edit</em> form</h3>\n<p>Our button looks nice but doesn&#8217;t do anything yet. To display an edit form, we need to have one first \u2013 let&#8217;s create it:</p>\n<pre><code class=\"language-js\">import { Button, TextControl } from '@wordpress/components';\nfunction EditPageForm( { pageId, onCancel, onSaveFinished } ) {\n    return (\n        &lt;div className=\"my-gutenberg-form\"&gt;\n            &lt;TextControl\n                __nextHasNoMarginBottom\n                __next40pxDefaultSize\n                value=&apos;&apos;\n                label='Page title:'\n            /&gt;\n            &lt;div className=\"form-buttons\"&gt;\n                &lt;Button onClick={ onSaveFinished } variant=\"primary\"&gt;\n                    Save\n                &lt;/Button&gt;\n                &lt;Button onClick={ onCancel } variant=\"tertiary\"&gt;\n                    Cancel\n                &lt;/Button&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n    );\n}\n</code></pre>\n<p>Now let&#8217;s make the button display the form we just created. As this tutorial is not focused on web design, we will wire the two together using a component that requires the least amount of code: <a href=\"https://developer.wordpress.org/block-editor/reference-guides/components/modal/\"><code>Modal</code></a>. Let&#8217;s update <code>PageEditButton</code> accordingly:</p>\n<pre><code class=\"language-js\">import { Button, Modal, TextControl } from '@wordpress/components';\n\nfunction PageEditButton({ pageId }) {\n    const [ isOpen, setOpen ] = useState( false );\n    const openModal = () =&gt; setOpen( true );\n    const closeModal = () =&gt; setOpen( false );\n    return (\n        &lt;&gt;\n            &lt;Button\n                onClick={ openModal }\n                variant=\"primary\"\n            &gt;\n                Edit\n            &lt;/Button&gt;\n            { isOpen &amp;&amp; (\n                &lt;Modal onRequestClose={ closeModal } title=\"Edit page\"&gt;\n                    &lt;EditPageForm\n                        pageId={pageId}\n                        onCancel={closeModal}\n                        onSaveFinished={closeModal}\n                    /&gt;\n                &lt;/Modal&gt;\n            ) }\n        &lt;/&gt;\n    )\n}\n</code></pre>\n<p>When you click the <em>Edit</em> button now, you should see the following modal:</p>\n<p><img data-recalc-dims=\"1\" decoding=\"async\" src=\"https://i0.wp.com/raw.githubusercontent.com/WordPress/gutenberg/HEAD/docs/how-to-guides/data-basics/media/edit-form/form-scaffold.png?ssl=1\" alt=\"\" /></p>\n<p>Great! We now have a basic user interface to work with.</p>\n<h3>Step 3: Populate the form with page details</h3>\n<p>We want the <code>EditPageForm</code> to display the title of the currently edited page. You may have noticed that it doesn&#8217;t receive a <code>page</code> prop, only <code>pageId</code>. That&#8217;s okay. Gutenberg Data allows us to easily access entity records from any component.</p>\n<p>In this case, we need to use the <a href=\"https://developer.wordpress.org/block-editor/reference-guides/data/data-core/#getentityrecord\"><code>getEntityRecord</code></a> selector. The list of records is already available thanks to the <code>getEntityRecords</code> call in <code>MyFirstApp</code>, so there won&#8217;t even be any additional HTTP requests involved \u2013 we&#8217;ll get the cached record right away.</p>\n<p>Here&#8217;s how you can try it in your browser&#8217;s dev tools:</p>\n<pre><code class=\"language-js\">wp.data.select( 'core' ).getEntityRecord( 'postType', 'page', 9 );  // Replace 9 with an actual page ID\n</code></pre>\n<p>Let&#8217;s update <code>EditPageForm</code> accordingly:</p>\n<pre><code class=\"language-js\">function EditPageForm( { pageId, onCancel, onSaveFinished } ) {\n    const page = useSelect(\n        select =&gt; select( coreDataStore ).getEntityRecord( 'postType', 'page', pageId ),\n        [pageId]\n    );\n    return (\n        &lt;div className=\"my-gutenberg-form\"&gt;\n            &lt;TextControl\n                __nextHasNoMarginBottom\n                __next40pxDefaultSize\n                label='Page title:'\n                value={ page.title.rendered }\n            /&gt;\n            { /* ... */ }\n        &lt;/div&gt;\n    );\n}\n</code></pre>\n<p>Now it should look like this:</p>\n<p><img data-recalc-dims=\"1\" decoding=\"async\" src=\"https://i0.wp.com/raw.githubusercontent.com/WordPress/gutenberg/HEAD/docs/how-to-guides/data-basics/media/edit-form/form-populated.png?ssl=1\" alt=\"\" /></p>\n<h3>Step 4: Making the Page title field editable</h3>\n<p>There&#8217;s one problem with our <em>Page title</em> field: you can&#8217;t edit it. It receives a fixed <code>value</code> but doesn&#8217;t update it when typing. We need an <code>onChange</code> handler.</p>\n<p>You may have seen a pattern similar to this one in other React apps. It&#8217;s known as a <a href=\"https://reactjs.org/docs/forms.html#controlled-components\">&#8220;controlled component&#8221;</a>:</p>\n<pre><code class=\"language-js\">function VanillaReactForm({ initialTitle }) {\n    const [title, setTitle] = useState( initialTitle );\n    return (\n        &lt;TextControl\n            __nextHasNoMarginBottom\n            __next40pxDefaultSize\n            value={ title }\n            onChange={ setTitle }\n        /&gt;\n    );\n}\n</code></pre>\n<p>Updating entity records in Gutenberg Data is similar but instead of using <code>setTitle</code> to store in local (component level) state, we use the <code>editEntityRecord</code> action which stores the updates in the <em>Redux</em> state. Here&#8217;s how you can try it out in your browser&#8217;s dev tools:</p>\n<pre><code class=\"language-js\">// We need a valid page ID to call editEntityRecord, so let's get the first available one using getEntityRecords.\nconst pageId = wp.data.select( 'core' ).getEntityRecords( 'postType', 'page' )[0].id;\n\n// Update the title\nwp.data.dispatch( 'core' ).editEntityRecord( 'postType', 'page', pageId, { title: 'updated title' } );\n</code></pre>\n<p>At this point, you may ask <em>how</em> is <code>editEntityRecord</code> better than <code>useState</code>? The answer is that it offers a few features you wouldn&#8217;t otherwise get.</p>\n<p>Firstly, we can save the changes as easily as we retrieve the data and ensure that all caches will be correctly updated.</p>\n<p>Secondly, the changes applied via <code>editEntityRecord</code> are easily undo-able via the <code>undo</code> and <code>redo</code> actions.</p>\n<p>Lastly, because the changes live in the <em>Redux</em> state, they are &#8220;global&#8221; and can be accessed by other components. For example, we could make the <code>PagesList</code> display the currently edited title.</p>\n<p>To that last point, let&#8217;s see what happens when we use <code>getEntityRecord</code> to access the entity record we just updated:</p>\n<pre><code class=\"language-js\">wp.data.select( 'core' ).getEntityRecord( 'postType', 'page', pageId ).title\n</code></pre>\n<p>It doesn&#8217;t reflect the edits. What&#8217;s going on?</p>\n<p>Well, <code>&lt;PagesList /&gt;</code> renders the data returned by <code>getEntityRecord()</code>. If <code>getEntityRecord()</code> reflected the updated title, then anything the user types in the <code>TextControl</code> would be immediately displayed inside <code>&lt;PagesList /&gt;</code>, too. This is not what we want. The edits shouldn&#8217;t leak outside the form until the user decides to save them.</p>\n<p>Gutenberg Data solves this problem by making a distinction between <em>Entity Records</em> and <em>Edited Entity Records</em>. <em>Entity Records</em> reflect the data from the API and ignore any local edits, while <em>Edited Entity Records</em> also have all the local edits applied on top. Both co-exist in the Redux state at the same time.</p>\n<p>Let&#8217;s see what happens if we call <code>getEditedEntityRecord</code>:</p>\n<pre><code class=\"language-js\">wp.data.select( 'core' ).getEditedEntityRecord( 'postType', 'page', pageId ).title\n// \"updated title\"\n\nwp.data.select( 'core' ).getEntityRecord( 'postType', 'page', pageId ).title\n// { \"rendered\": \"&lt;original, unchanged title&gt;\", \"raw\": \"...\" }\n</code></pre>\n<p>As you can see, the <code>title</code> of an Entity Record is an object, but the <code>title</code> of an Edited Entity record is a string.</p>\n<p>This is no accident. Fields like <code>title</code>, <code>excerpt</code>, and <code>content</code> may contain <a href=\"https://developer.wordpress.org/apis/handbook/shortcode/\">shortcodes</a> or <a href=\"https://developer.wordpress.org/block-editor/how-to-guides/block-tutorial/creating-dynamic-blocks/\">dynamic blocks</a>, which means they can only be rendered on the server. For such fields, the REST API exposes both the <code>raw</code> markup <em>and</em> the <code>rendered</code> string. For example, in the block editor, <code>content.rendered</code> could used as a visual preview, and <code>content.raw</code> could be used to populate the code editor.</p>\n<p>So why is the <code>content</code> of an Edited Entity Record a string? Since JavaScript is not be able to properly render arbitrary block markup, it stores only the <code>raw</code> markup without the <code>rendered</code> part. And since that&#8217;s a string, the entire field becomes a string.</p>\n<p>We can now update <code>EditPageForm</code> accordingly. We can access the actions using the <a href=\"https://developer.wordpress.org/block-editor/reference-guide/packages/packages-data/#usedispatch\"><code>useDispatch</code></a> hook similarly to how we use <code>useSelect</code> to access selectors:</p>\n<pre><code class=\"language-js\">import { useDispatch } from '@wordpress/data';\n\nfunction EditPageForm( { pageId, onCancel, onSaveFinished } ) {\n    const page = useSelect(\n        select =&gt; select( coreDataStore ).getEditedEntityRecord( 'postType', 'page', pageId ),\n        [ pageId ]\n    );\n    const { editEntityRecord } = useDispatch( coreDataStore );\n    const handleChange = ( title ) =&gt; editEntityRecord( 'postType', 'page', pageId, { title } );\n\n    return (\n        &lt;div className=\"my-gutenberg-form\"&gt;\n            &lt;TextControl\n                __nextHasNoMarginBottom\n                __next40pxDefaultSize\n                label=\"Page title:\"\n                value={ page.title }\n                onChange={ handleChange }\n            /&gt;\n            &lt;div className=\"form-buttons\"&gt;\n                &lt;Button onClick={ onSaveFinished } variant=\"primary\"&gt;\n                    Save\n                &lt;/Button&gt;\n                &lt;Button onClick={ onCancel } variant=\"tertiary\"&gt;\n                    Cancel\n                &lt;/Button&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n    );\n}\n</code></pre>\n<p>We added an <code>onChange</code> handler to keep track of edits via the <code>editEntityRecord</code> action and then changed the selector to <code>getEditedEntityRecord</code> so that <code>page.title</code> always reflects the changes.</p>\n<p>This is what it looks like now:</p>\n<p><img data-recalc-dims=\"1\" decoding=\"async\" src=\"https://i0.wp.com/raw.githubusercontent.com/WordPress/gutenberg/HEAD/docs/how-to-guides/data-basics/media/edit-form/form-editable.png?ssl=1\" alt=\"\" /></p>\n<h3>Step 5: Saving the form data</h3>\n<p>Now that we can edit the page title let&#8217;s also make sure we can save it. In Gutenberg data, we save changes to the WordPress REST API using the <code>saveEditedEntityRecord</code> action. It sends the request, processes the result, and updates the cached data in the Redux state.</p>\n<p>Here&#8217;s an example you may try in your browser&#8217;s dev tools:</p>\n<pre><code class=\"language-js\">// Replace 9 with an actual page ID\nwp.data.dispatch( 'core' ).editEntityRecord( 'postType', 'page', 9, { title: 'updated title' } );\nwp.data.dispatch( 'core' ).saveEditedEntityRecord( 'postType', 'page', 9 );\n</code></pre>\n<p>The above snippet saved a new title. Unlike before, <code>getEntityRecord</code> now reflects the updated title:</p>\n<pre><code class=\"language-js\">// Replace 9 with an actual page ID\nwp.data.select( 'core' ).getEntityRecord( 'postType', 'page', 9 ).title.rendered\n// \"updated title\"\n</code></pre>\n<p>Entity records are updated to reflect any saved changes right after the REST API request is finished.</p>\n<p>This is how the <code>EditPageForm</code> looks like with a working <em>Save</em> button:</p>\n<pre><code class=\"language-js\">function EditPageForm( { pageId, onCancel, onSaveFinished } ) {\n    // ...\n    const { saveEditedEntityRecord } = useDispatch( coreDataStore );\n    const handleSave = () =&gt; saveEditedEntityRecord( 'postType', 'page', pageId );\n\n    return (\n        &lt;div className=\"my-gutenberg-form\"&gt;\n            {/* ... */}\n            &lt;div className=\"form-buttons\"&gt;\n                &lt;Button onClick={ handleSave } variant=\"primary\"&gt;\n                    Save\n                &lt;/Button&gt;\n                {/* ... */}\n            &lt;/div&gt;\n        &lt;/div&gt;\n    );\n}\n</code></pre>\n<p>It works, but there&#8217;s still one thing to fix: the form modal doesn&#8217;t automatically close because we never call <code>onSaveFinished</code>. Lucky for us, <code>saveEditedEntityRecord</code> returns a promise that resolves once the save operation is finished. Let&#8217;s take advantage of it in <code>EditPageForm</code>:</p>\n<pre><code class=\"language-js\">function EditPageForm( { pageId, onCancel, onSaveFinished } ) {\n    // ...\n    const handleSave = async () =&gt; {\n        await saveEditedEntityRecord( 'postType', 'page', pageId );\n        onSaveFinished();\n    };\n    // ...\n}\n</code></pre>\n<h3>Step 6: Handle errors</h3>\n<p>We optimistically assumed that a <em>save</em> operation would always succeed. Unfortunately, it may fail in many ways:</p>\n<ul>\n<li>The website can be down</li>\n<li>The update may be invalid</li>\n<li>The page could have been deleted by someone else in the meantime</li>\n</ul>\n<p>To tell the user when any of these happens, we have to make two adjustments. We don&#8217;t want to close the form modal when the update fails. The promise returned by <code>saveEditedEntityRecord</code> is resolved with an updated record only if the update actually worked. When something goes wrong, it resolves with an empty value. Let&#8217;s use it to keep the modal open:</p>\n<pre><code class=\"language-js\">function EditPageForm( { pageId, onSaveFinished } ) {\n    // ...\n    const handleSave = async () =&gt; {\n        const updatedRecord = await saveEditedEntityRecord( 'postType', 'page', pageId );\n        if ( updatedRecord ) {\n            onSaveFinished();\n        }\n    };\n    // ...\n}\n</code></pre>\n<p>Great! Now, let&#8217;s display an error message. The failure details can be grabbed using the <code>getLastEntitySaveError</code> selector:</p>\n<pre><code class=\"language-js\">// Replace 9 with an actual page ID\nwp.data.select( 'core' ).getLastEntitySaveError( 'postType', 'page', 9 )\n</code></pre>\n<p>Here&#8217;s how we can use it in <code>EditPageForm</code>:</p>\n<pre><code class=\"language-js\">function EditPageForm( { pageId, onSaveFinished } ) {\n    // ...\n    const { lastError, page } = useSelect(\n        select =&gt; ({\n            page: select( coreDataStore ).getEditedEntityRecord( 'postType', 'page', pageId ),\n            lastError: select( coreDataStore ).getLastEntitySaveError( 'postType', 'page', pageId )\n        }),\n        [ pageId ]\n    )\n    // ...\n    return (\n        &lt;div className=\"my-gutenberg-form\"&gt;\n            {/* ... */}\n            { lastError ? (\n                &lt;div className=\"form-error\"&gt;\n                    Error: { lastError.message }\n                &lt;/div&gt;\n            ) : false }\n            {/* ... */}\n        &lt;/div&gt;\n    );\n}\n</code></pre>\n<p>Great! <code>EditPageForm</code> is now fully aware of errors.</p>\n<p>Let&#8217;s see that error message in action. We&#8217;ll trigger an invalid update and let it fail. The post title is hard to break, so let&#8217;s set a <code>date</code> property to <code>-1</code> instead \u2013 that&#8217;s a guaranteed validation error:</p>\n<pre><code class=\"language-js\">function EditPageForm( { pageId, onCancel, onSaveFinished } ) {\n    // ...\n    const handleChange = ( title ) =&gt; editEntityRecord( 'postType', 'page', pageId, { title, date: -1 } );\n    // ...\n}\n</code></pre>\n<p>Once you refresh the page, open the form, change the title, and hit save, you should see the following error message:</p>\n<p><img data-recalc-dims=\"1\" decoding=\"async\" src=\"https://i0.wp.com/raw.githubusercontent.com/WordPress/gutenberg/HEAD/docs/how-to-guides/data-basics/media/edit-form/form-error.png?ssl=1\" alt=\"\" /></p>\n<p>Fantastic! We can now <strong>restore the previous version of <code>handleChange</code></strong> and move on to the next step.</p>\n<h3>Step 7: Status indicator</h3>\n<p>There is one last problem with our form: no visual feedback. We can\u2019t be quite sure whether the <em>Save</em> button worked until either the form disappears or an error message shows.</p>\n<p>We&#8217;re going to clear it up and communicate two states to the user: <em>Saving</em> and <em>No changes detected</em>. The relevant selectors are <code>isSavingEntityRecord</code> and <code>hasEditsForEntityRecord</code>. Unlike <code>getEntityRecord</code>, they never issue any HTTP requests but only return the current entity record state.</p>\n<p>Let&#8217;s use them in <code>EditPageForm</code>:</p>\n<pre><code class=\"language-js\">function EditPageForm( { pageId, onSaveFinished } ) {\n    // ...\n    const { isSaving, hasEdits, /* ... */ } = useSelect(\n        select =&gt; ({\n            isSaving: select( coreDataStore ).isSavingEntityRecord( 'postType', 'page', pageId ),\n            hasEdits: select( coreDataStore ).hasEditsForEntityRecord( 'postType', 'page', pageId ),\n            // ...\n        }),\n        [ pageId ]\n    )\n}\n</code></pre>\n<p>We can now use <code>isSaving</code> and <code>hasEdits</code> to display a spinner when saving is in progress and grey out the save button when there are no edits:</p>\n<pre><code class=\"language-js\">function EditPageForm( { pageId, onSaveFinished } ) {\n    // ...\n    return (\n        // ...\n        &lt;div className=\"form-buttons\"&gt;\n            &lt;Button onClick={ handleSave } variant=\"primary\" disabled={ ! hasEdits || isSaving }&gt;\n                { isSaving ? (\n                    &lt;&gt;\n                        &lt;Spinner/&gt;\n                        Saving\n                    &lt;/&gt;\n                ) : 'Save' }\n            &lt;/Button&gt;\n            &lt;Button\n                onClick={ onCancel }\n                variant=\"tertiary\"\n                disabled={ isSaving }\n            &gt;\n                Cancel\n            &lt;/Button&gt;\n        &lt;/div&gt;\n        // ...\n    );\n}\n</code></pre>\n<p>Note that we disable the <em>save</em> button when there are no edits and when the page is currently being saved. This is to prevent the user from accidentally pressing the button twice.</p>\n<p>Also, interrupting a <em>save</em> in progress is not supported by <code>@wordpress/data</code> so we also conditionally disabled the <em>cancel</em> button.</p>\n<p>Here&#8217;s what it looks like in action:</p>\n<p><img data-recalc-dims=\"1\" decoding=\"async\" src=\"https://i0.wp.com/raw.githubusercontent.com/WordPress/gutenberg/HEAD/docs/how-to-guides/data-basics/media/edit-form/form-inactive.png?ssl=1\" alt=\"\" /><br />\n<img data-recalc-dims=\"1\" decoding=\"async\" src=\"https://i0.wp.com/raw.githubusercontent.com/WordPress/gutenberg/HEAD/docs/how-to-guides/data-basics/media/edit-form/form-spinner.png?ssl=1\" alt=\"\" /></p>\n<h3>Wiring it all together</h3>\n<p>All the pieces are in place, great! Here\u2019s everything we built in this chapter in one place:</p>\n<pre><code class=\"language-js\">import { useDispatch } from '@wordpress/data';\nimport { Button, Modal, TextControl } from '@wordpress/components';\n\nfunction PageEditButton( { pageId } ) {\n    const [ isOpen, setOpen ] = useState( false );\n    const openModal = () =&gt; setOpen( true );\n    const closeModal = () =&gt; setOpen( false );\n    return (\n        &lt;&gt;\n            &lt;Button onClick={ openModal } variant=\"primary\"&gt;\n                Edit\n            &lt;/Button&gt;\n            { isOpen &amp;&amp; (\n                &lt;Modal onRequestClose={ closeModal } title=\"Edit page\"&gt;\n                    &lt;EditPageForm\n                        pageId={ pageId }\n                        onCancel={ closeModal }\n                        onSaveFinished={ closeModal }\n                    /&gt;\n                &lt;/Modal&gt;\n            ) }\n        &lt;/&gt;\n    );\n}\n\nfunction EditPageForm( { pageId, onCancel, onSaveFinished } ) {\n    const { page, lastError, isSaving, hasEdits } = useSelect(\n        ( select ) =&gt; ( {\n            page: select( coreDataStore ).getEditedEntityRecord( 'postType', 'page', pageId ),\n            lastError: select( coreDataStore ).getLastEntitySaveError( 'postType', 'page', pageId ),\n            isSaving: select( coreDataStore ).isSavingEntityRecord( 'postType', 'page', pageId ),\n            hasEdits: select( coreDataStore ).hasEditsForEntityRecord( 'postType', 'page', pageId ),\n        } ),\n        [ pageId ]\n    );\n\n    const { saveEditedEntityRecord, editEntityRecord } = useDispatch( coreDataStore );\n    const handleSave = async () =&gt; {\n        const savedRecord = await saveEditedEntityRecord( 'postType', 'page', pageId );\n        if ( savedRecord ) {\n            onSaveFinished();\n        }\n    };\n    const handleChange = ( title ) =&gt;  editEntityRecord( 'postType', 'page', page.id, { title } );\n\n    return (\n        &lt;div className=\"my-gutenberg-form\"&gt;\n            &lt;TextControl\n                __nextHasNoMarginBottom\n                __next40pxDefaultSize\n                label=\"Page title:\"\n                value={ page.title }\n                onChange={ handleChange }\n            /&gt;\n            { lastError ? (\n                &lt;div className=\"form-error\"&gt;Error: { lastError.message }&lt;/div&gt;\n            ) : (\n                false\n            ) }\n            &lt;div className=\"form-buttons\"&gt;\n                &lt;Button\n                    onClick={ handleSave }\n                    variant=\"primary\"\n                    disabled={ ! hasEdits || isSaving }\n                &gt;\n                    { isSaving ? (\n                        &lt;&gt;\n                            &lt;Spinner/&gt;\n                            Saving\n                        &lt;/&gt;\n                    ) : 'Save' }\n                &lt;/Button&gt;\n                &lt;Button\n                    onClick={ onCancel }\n                    variant=\"tertiary\"\n                    disabled={ isSaving }\n                &gt;\n                    Cancel\n                &lt;/Button&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n    );\n}\n</code></pre>\n<h2>What&#8217;s next?</h2>\n<ul>\n<li><strong>Previous part:</strong> <a href=\"https://developer.wordpress.org/block-editor/how-to-guides/data-basics/2-building-a-list-of-pages/\">Building a list of pages</a></li>\n<li><strong>Next part:</strong> <a href=\"https://developer.wordpress.org/block-editor/how-to-guides/data-basics/4-building-a-create-page-form/\">Building a Create Page form</a></li>\n<li>(optional) Review the <a href=\"https://github.com/WordPress/block-development-examples/tree/trunk/plugins/data-basics-59c8f8\">finished app</a> in the block-development-examples repository</li>\n</ul>\n",
        "protected": false
    },
    "author": 0,
    "featured_media": 0,
    "parent": 140129,
    "menu_order": 32,
    "template": "",
    "meta": {
        "footnotes": ""
    },
    "class_list": [
        "post-140326",
        "blocks-handbook",
        "type-blocks-handbook",
        "status-publish",
        "hentry",
        "type-handbook"
    ],
    "revision_note": "",
    "jetpack_sharing_enabled": true,
    "_links": {
        "self": [
            {
                "href": "https://developer.wordpress.org/wp-json/wp/v2/blocks-handbook/140326",
                "targetHints": {
                    "allow": [
                        "GET"
                    ]
                }
            }
        ],
        "collection": [
            {
                "href": "https://developer.wordpress.org/wp-json/wp/v2/blocks-handbook"
            }
        ],
        "about": [
            {
                "href": "https://developer.wordpress.org/wp-json/wp/v2/types/blocks-handbook"
            }
        ],
        "version-history": [
            {
                "count": 9,
                "href": "https://developer.wordpress.org/wp-json/wp/v2/blocks-handbook/140326/revisions"
            }
        ],
        "predecessor-version": [
            {
                "id": 155762,
                "href": "https://developer.wordpress.org/wp-json/wp/v2/blocks-handbook/140326/revisions/155762"
            }
        ],
        "up": [
            {
                "embeddable": true,
                "href": "https://developer.wordpress.org/wp-json/wp/v2/blocks-handbook/140129"
            }
        ],
        "wp:attachment": [
            {
                "href": "https://developer.wordpress.org/wp-json/wp/v2/media?parent=140326"
            }
        ],
        "curies": [
            {
                "name": "wp",
                "href": "https://api.w.org/{rel}",
                "templated": true
            }
        ]
    }
}