{
    "id": 154869,
    "date": "2024-08-19T10:55:01",
    "date_gmt": "2024-08-19T10:55:01",
    "guid": {
        "rendered": "https://developer.wordpress.org/block-editor/reference-guides/interactivity-api/core-concepts/the-reactive-and-declarative-mindset/"
    },
    "modified": "2025-01-14T08:49:06",
    "modified_gmt": "2025-01-14T08:49:06",
    "slug": "the-reactive-and-declarative-mindset",
    "status": "publish",
    "type": "blocks-handbook",
    "link": "https://developer.wordpress.org/block-editor/reference-guides/interactivity-api/core-concepts/the-reactive-and-declarative-mindset/",
    "title": {
        "rendered": "The Reactive and Declarative mindset"
    },
    "content": {
        "rendered": "<p>The Interactivity API is a reactive and declarative framework, similar to other modern frameworks like React, Vue, Svelte, or Alpine. When working with the Interactivity API, adopting the right mindset is crucial for maximizing its potential. This guide will explain the core concepts of reactivity and declarativeness, providing a foundation for effective use of the Interactivity API.</p>\n<h2>Declarative vs. imperative</h2>\n<p><strong>Declarative Programming</strong> describes <em>what</em> a program should accomplish. It focuses on the desired outcome without explicitly listing commands or steps to achieve that result. In contrast, <strong>imperative programming</strong> specifies <em>how</em> to accomplish tasks by explicitly stating each step to manipulate the program\u2019s state.</p>\n<h3>The imperative approach</h3>\n<p>In the early days of web development, the imperative approach was predominant. This method involves manually updating the DOM with JavaScript to reflect changes.</p>\n<p>Take, for example, this interactive block with two buttons and a paragraph:</p>\n<ul>\n<li><strong>The show/hide button</strong>: Toggles paragraph visibility and enables/disables the &#8220;Activate&#8221; button.</li>\n<li><strong>The activate/deactivate button</strong>: Toggles the paragraph&#8217;s text and color between &#8220;active&#8221; (green) and &#8220;inactive&#8221; (red).</li>\n</ul>\n<pre><code class=\"language-html\">&lt;div id=\"my-interactive-plugin\"&gt;\n    &lt;button\n        id=\"show-hide-btn\"\n        aria-expanded=\"false\"\n        aria-controls=\"status-paragraph\"\n    &gt;\n        show\n    &lt;/button&gt;\n    &lt;button id=\"activate-btn\" disabled&gt;activate&lt;/button&gt;\n    &lt;p id=\"status-paragraph\" class=\"inactive\" hidden&gt;this is inactive&lt;/p&gt;\n&lt;/div&gt;\n\n&lt;style&gt;\n    .active {\n        color: green;\n    }\n    .inactive {\n        color: red;\n    }\n&lt;/style&gt;\n\n&lt;script&gt;\n    const showHideBtn = document.getElementById( 'show-hide-btn' );\n    const activateBtn = document.getElementById( 'activate-btn' );\n    const statusParagraph = document.getElementById( 'status-paragraph' );\n\n    showHideBtn.addEventListener( 'click', () =&gt; {\n        if ( statusParagraph.hasAttribute( 'hidden' ) ) {\n            statusParagraph.removeAttribute( 'hidden' );\n            showHideBtn.textContent = 'hide';\n            showHideBtn.setAttribute( 'aria-expanded', 'true' );\n            activateBtn.removeAttribute( 'disabled' );\n        } else {\n            if ( statusParagraph.classList.contains( 'active' ) ) {\n                statusParagraph.textContent = 'this is inactive';\n                statusParagraph.classList.remove( 'active' );\n                activateBtn.textContent = 'activate';\n            }\n            statusParagraph.setAttribute( 'hidden', true );\n            showHideBtn.textContent = 'show';\n            showHideBtn.setAttribute( 'aria-expanded', 'false' );\n            activateBtn.setAttribute( 'disabled', true );\n        }\n    } );\n\n    activateBtn.addEventListener( 'click', () =&gt; {\n        if ( activateBtn.textContent === 'activate' ) {\n            statusParagraph.textContent = 'this is active';\n            statusParagraph.classList.remove( 'inactive' );\n            statusParagraph.classList.add( 'active' );\n            activateBtn.textContent = 'deactivate';\n        } else {\n            statusParagraph.textContent = 'this is inactive';\n            statusParagraph.classList.remove( 'active' );\n            statusParagraph.classList.add( 'inactive' );\n            activateBtn.textContent = 'activate';\n        }\n    } );\n&lt;/script&gt;\n</code></pre>\n<p>As you can see, for each condition, you have to use JavaScript to modify everything in the DOM that has changed, taking into account the previous state.</p>\n<h3>The declarative approach</h3>\n<p>The declarative approach simplifies the process by focusing on <em>what</em> should happen. The UI updates automatically in response to changes in state. Here is a similar example using the Interactivity API&#8217;s declarative approach:</p>\n<pre><code class=\"language-html\">&lt;div id=\"my-interactive-plugin\" data-wp-interactive=\"myInteractivePlugin\"&gt;\n    &lt;button\n        data-wp-on--click=\"actions.toggleVisibility\"\n        data-wp-bind--aria-expanded=\"state.isVisible\"\n        data-wp-text=\"state.visibilityText\"\n        aria-controls=\"status-paragraph\"\n    &gt;\n        show\n    &lt;/button&gt;\n    &lt;button\n        data-wp-on--click=\"actions.toggleActivation\"\n        data-wp-bind--disabled=\"!state.isVisible\"\n        data-wp-text=\"state.activationText\"\n    &gt;\n        activate\n    &lt;/button&gt;\n    &lt;p\n        id=\"status-paragraph\"\n        data-wp-bind--hidden=\"!state.isVisible\"\n        data-wp-class--active=\"state.isActive\"\n        data-wp-class--inactive=\"!state.isActive\"\n        data-wp-text=\"state.paragraphText\"\n    &gt;\n        this is inactive\n    &lt;/p&gt;\n&lt;/div&gt;\n\n&lt;style&gt;\n    .active {\n        color: green;\n    }\n    .inactive {\n        color: red;\n    }\n&lt;/style&gt;\n</code></pre>\n<pre><code class=\"language-js\">import { store } from '@wordpress/interactivity';\n\nconst { state } = store( 'myInteractivePlugin', {\n    state: {\n        isVisible: false,\n        isActive: false,\n        get visibilityText() {\n            return state.isVisible ? 'hide' : 'show';\n        },\n        get activationText() {\n            return state.isActive ? 'deactivate' : 'activate';\n        },\n        get paragraphText() {\n            return state.isActive ? 'this is active' : 'this is inactive';\n        },\n    },\n    actions: {\n        toggleVisibility() {\n            state.isVisible = ! state.isVisible;\n            if ( ! state.isVisible ) state.isActive = false;\n        },\n        toggleActivation() {\n            state.isActive = ! state.isActive;\n        },\n    },\n} );\n</code></pre>\n<p>In this declarative example, the UI automatically updates based on the current state. All you have to do as developers is to declare the necessary state, any derived state, the actions that modify the state, and which parts of the DOM depend on which parts of the state. The framework takes care of making all the necessary updates to the DOM so that it is always in sync with the current state. The logic remains simple and maintainable regardless of the number of elements controlled by the framework.</p>\n<h3>Can you spot the bug?</h3>\n<p>In the imperative example, a bug has been intentionally introduced for didactical purposes. Can you find it? It&#8217;s not easy!</p>\n<details>\n<summary>Show me the answer!</summary>\n<p>In the case that the Show button is pressed first, then the Activate button, and finally the Hide button, it doesn&#8217;t add the <code>inactive</code> class using <code>statusParagraph.classList.add('inactive');</code>. Therefore, the next time the user presses Show, the paragraph will not appear in red.</p>\n</details>\n<p>These types of bugs are very common in imperative code because you have to manually control all the conditions. On the other hand, they do not exist in declarative code because the framework takes care of updating the DOM and never forgets about anything.</p>\n<h3>Benefits of the declarative approach</h3>\n<p>As demonstrated, the imperative approach requires detailed steps and direct manipulation of the DOM, which can quickly become complex and hard to maintain as the interactivity complexity grows. The more possible states and elements there are, the more conditional logic needs to be added, making the code exponentially more complicated. The declarative approach, on the other hand, simplifies the process by managing the state and letting the framework handle the DOM updates. This leads to more readable, maintainable, and scalable code.</p>\n<h2>Reactivity</h2>\n<p>The Interactivity API is a declarative framework thanks to its leverage of reactivity. In a reactive system, changes to the data automatically trigger updates in the user interface, ensuring that the view always reflects the current state of the application.</p>\n<h3>How reactivity works</h3>\n<p>The Interactivity API uses a fine-grained reactivity system. Here&#8217;s how it works:</p>\n<ol>\n<li><strong>Reactive State</strong>: In the Interactivity API, both the global state and the local context are reactive. This means that when either of these data sources changes, any parts of the UI that depend on them will automatically update.\n<ul>\n<li><strong>Global state</strong>: This is global data that can be accessed throughout your interactive blocks.</li>\n<li><strong>Local context</strong>: This is local data that is specific to a particular element and its children.</li>\n<li><strong>Derived State</strong>: In addition to basic state properties, you can define computed properties that automatically update when their dependencies change.</li>\n</ul>\n<p><em>Please, visit the <a href=\"https://developer.wordpress.org/block-editor/reference-guides/interactivity-api/core-concepts/undestanding-global-state-local-context-and-derived-state/\">Understanding global state, local context and derived state</a> guide to learn more about how to work with the different types of reactive state in the Interactivity API.</em></p>\n</li>\n<li>\n<p><strong>Actions</strong>: These are functions, usually triggered by event handlers, that mutate the global state or local context.</p>\n</li>\n<li>\n<p><strong>Reactive Bindings</strong>: HTML elements are bound to reactive state values using special attributes like <code>data-wp-bind</code>, <code>data-wp-text</code>, or <code>data-wp-class</code>.</p>\n</li>\n<li>\n<p><strong>Automatic Updates</strong>: When the actions mutate the global state or local context, the Interactivity API automatically updates all the parts of the DOM that depend on that state (either directly or through the derived state).</p>\n</li>\n</ol>\n<p>Let&#8217;s break down these concepts by reviewing the previous example:</p>\n<pre><code class=\"language-javascript\">const { state } = store( 'myInteractivePlugin', {\n    state: {\n        isVisible: false,\n        isActive: false,\n        get visibilityText() {\n            return state.isVisible ? 'hide' : 'show';\n        },\n        // ... other derived state\n    },\n    actions: {\n        toggleVisibility() {\n            state.isVisible = ! state.isVisible;\n        },\n        // ... other actions\n    },\n} );\n</code></pre>\n<p>In this code:</p>\n<ul>\n<li><code>isVisible</code> and <code>isActive</code> are basic state properties.</li>\n<li><code>visibilityText</code> is a derived state that automatically updates when <code>isVisible</code> changes.</li>\n<li><code>toggleVisibility</code> is an action that modifies the state.</li>\n</ul>\n<p>The HTML bindings look like this:</p>\n<pre><code class=\"language-html\">&lt;button\n    data-wp-on--click=\"actions.toggleVisibility\"\n    data-wp-text=\"state.visibilityText\"\n    data-wp-bind--aria-expanded=\"state.isVisible\"\n&gt;\n    show\n&lt;/button&gt;\n</code></pre>\n<p>Here&#8217;s how reactivity works in practice:</p>\n<ol>\n<li>When the button is clicked, it triggers the <code>toggleVisibility</code> action.</li>\n<li>This action updates <code>state.isVisible</code>.</li>\n<li>The Interactivity API detects this change and automatically:\n<ul>\n<li>Updates the button&#8217;s text content (because of <code>data-wp-text=\"state.visibilityText\"</code>).</li>\n<li>Changes the <code>aria-expanded</code> attribute (due to <code>data-wp-bind--aria-expanded=\"state.isVisible\"</code>).</li>\n<li>Updates any other parts of the DOM that depend on <code>isVisible</code> or <code>visibilityText</code>.</li>\n</ul>\n</li>\n</ol>\n<h3>Mutability vs immutability</h3>\n<p>Unlike many other reactive frameworks, <strong>the Interactivity API does not require the use of immutability</strong> when updating the global state or the local context. You can directly mutate objects and arrays, and the reactivity system will still work as expected. This can lead to more intuitive and straightforward code in many cases.</p>\n<p>For example, you can push a new item to an array like this:</p>\n<pre><code class=\"language-javascript\">const { state } = store( 'myArrayPlugin', {\n    state: {\n        list: [ 'item 1', 'item 2' ],\n    },\n    actions: {\n        addItem() {\n            // Right:\n            state.list.push( 'new item' );\n\n            // Wrong:\n            state.list = [ ...state.list, 'new item' ]; // Don't do this!\n        },\n    },\n} );\n</code></pre>\n<p>There&#8217;s no need to create a new array or use the spread operator as you might in other frameworks. The Interactivity API will detect this change and update any parts of the UI that depend on <code>state.list</code>.</p>\n<h3>Reactive side effects</h3>\n<p>In addition to automatically updating the UI, the Interactivity API allows you to perform side effects when reactive data changes using directives like <code>data-wp-watch</code>. Side effects are useful for tasks like logging, making API calls, or updating other parts of your application that aren&#8217;t directly tied to the UI.</p>\n<p>Here&#8217;s an example of how you might use <code>data-wp-watch</code>:</p>\n<pre><code class=\"language-html\">&lt;div\n    data-wp-interactive=\"myCounterPlugin\"\n    data-wp-context='{ \"counter\": 0 }'\n    data-wp-watch=\"callbacks.logCounter\"\n&gt;\n    &lt;p&gt;Counter: &lt;span data-wp-text=\"context.counter\"&gt;&lt;/span&gt;&lt;/p&gt;\n    &lt;button data-wp-on--click=\"actions.increment\"&gt;Increment&lt;/button&gt;\n&lt;/div&gt;\n</code></pre>\n<pre><code class=\"language-javascript\">store( 'myCounterPlugin', {\n    actions: {\n        increment() {\n            const context = getContext();\n            context.counter += 1;\n        },\n    },\n    callbacks: {\n        logCounter: () =&gt; {\n            const context = getContext();\n            console.log( `The counter is now: ${ context.counter }` );\n        },\n    },\n} );\n</code></pre>\n<p>In this example:</p>\n<ol>\n<li>The <code>data-wp-context</code> directive adds a local context with a property <code>counter</code> whose value is <code>0</code>.</li>\n<li>The <code>data-wp-watch</code> directive is set to <code>callbacks.logCounter</code>.</li>\n<li>Every time <code>context.counter</code> changes, the <code>logCounter</code> callback will be executed.</li>\n<li>The <code>logCounter</code> callback logs the current counter to the console.</li>\n</ol>\n<p>This allows you to create declarative side effects that automatically run in response to data changes. Some other use cases for <code>data-wp-watch</code> might include:</p>\n<ul>\n<li>Saving data to <code>localStorage</code> when the data changes.</li>\n<li>Sending analytics events.</li>\n<li>Changing the focus for accessibility purposes.</li>\n<li>Updating the page title, meta tags, or <code>&lt;body&gt;</code> attributes.</li>\n<li>Triggering animations.</li>\n</ul>\n<h2>Conclusion</h2>\n<p>As you continue to work with the Interactivity API, remember to think in terms of state, actions, and side effects. Define your data, describe how it should change, and let the Interactivity API handle the rest. This mental shift may take some time, especially if you&#8217;re used to more imperative programming styles, but by embracing it, you&#8217;ll unlock the full potential of the Interactivity API to create truly dynamic and interactive WordPress blocks that delight your users.</p>\n",
        "protected": false
    },
    "author": 0,
    "featured_media": 0,
    "parent": 154868,
    "menu_order": 85,
    "template": "",
    "meta": {
        "footnotes": ""
    },
    "class_list": [
        "post-154869",
        "blocks-handbook",
        "type-blocks-handbook",
        "status-publish",
        "hentry",
        "type-handbook"
    ],
    "revision_note": "",
    "jetpack_sharing_enabled": true,
    "_links": {
        "self": [
            {
                "href": "https://developer.wordpress.org/wp-json/wp/v2/blocks-handbook/154869",
                "targetHints": {
                    "allow": [
                        "GET"
                    ]
                }
            }
        ],
        "collection": [
            {
                "href": "https://developer.wordpress.org/wp-json/wp/v2/blocks-handbook"
            }
        ],
        "about": [
            {
                "href": "https://developer.wordpress.org/wp-json/wp/v2/types/blocks-handbook"
            }
        ],
        "version-history": [
            {
                "count": 3,
                "href": "https://developer.wordpress.org/wp-json/wp/v2/blocks-handbook/154869/revisions"
            }
        ],
        "predecessor-version": [
            {
                "id": 156197,
                "href": "https://developer.wordpress.org/wp-json/wp/v2/blocks-handbook/154869/revisions/156197"
            }
        ],
        "up": [
            {
                "embeddable": true,
                "href": "https://developer.wordpress.org/wp-json/wp/v2/blocks-handbook/154868"
            }
        ],
        "wp:attachment": [
            {
                "href": "https://developer.wordpress.org/wp-json/wp/v2/media?parent=154869"
            }
        ],
        "curies": [
            {
                "name": "wp",
                "href": "https://api.w.org/{rel}",
                "templated": true
            }
        ]
    }
}