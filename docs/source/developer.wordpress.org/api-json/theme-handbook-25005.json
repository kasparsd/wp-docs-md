{
    "id": 25005,
    "date": "2017-01-10T03:08:03",
    "date_gmt": "2017-01-10T03:08:03",
    "guid": {
        "rendered": "https://developer.wordpress.org/?post_type=theme-handbook&#038;p=25005"
    },
    "modified": "2018-01-20T20:49:27",
    "modified_gmt": "2018-01-20T20:49:27",
    "slug": "tools-for-improved-user-experience",
    "status": "publish",
    "type": "theme-handbook",
    "link": "https://developer.wordpress.org/themes/customize-api/tools-for-improved-user-experience/",
    "title": {
        "rendered": "Tools for Improved User Experience"
    },
    "content": {
        "rendered": "<h2>Contextual Controls, Sections, and Panels</h2>\r\nWordPress 4.0 and 4.1 also added support for making parts of the Customizer UI be visible or hidden depending on the part of the site that the user was previewing within the Customizer preview window.\u00a0A simple contextual control example would be that your theme only displays the header image and the site tagline on the front page. This is a perfect use case for the Customizer Manager&#8217;s get_ methods, as we can modify the core controls for these settings directly to make them contextual to the front page:\r\n\r\n<pre class=\"wp-block-code\"><code lang=\"php\" class=\"language-php \">// Hide core sections/controls when they aren't used on the current page.\r\n$wp_customize-&gt;get_section( 'header_image' )-&gt;active_callback = 'is_front_page';\r\n$wp_customize-&gt;get_control( 'blogdescription' )-&gt;active_callback = 'is_front_page';</code></pre>\r\n\r\n<figure style=\"width: 848px\" class=\"wp-caption alignnone\"><img loading=\"lazy\" decoding=\"async\" class=\"\"  src=\"//i1.wp.com/nick.halsey.co/wp-content/uploads/sites/2/2014/08/contextual-customize-controls.gif\" alt=\"\" width=\"848\" height=\"525\" /><figcaption class=\"wp-caption-text\">In this contextual control example, the theme only displays the site tagline on the front page, so the corresponding field in the Customizer is hidden when the user navigates to a different page within the preview window.</figcaption></figure>\r\n\r\nThe <code>active_callback</code> parameter for Panels, Sections, and Controls takes a callback function name, either core or custom. This parameter can also be set when registering the object for objects\u00a0that you add. Here&#8217;s an example from the Twenty Fourteen Theme:\r\n\r\n<pre class=\"wp-block-code\"><code lang=\"php\" class=\"language-php line-numbers\">$wp_customize-&gt;add_section( 'featured_content', array(\r\n  'title'       =&gt; __( 'Featured Content', 'twentyfourteen' ),\r\n  'description' =&gt; //...\r\n  'priority'        =&gt; 130,\r\n  'active_callback' =&gt; 'is_front_page',\r\n) );</code></pre>\r\n\r\nIn the previous example, <code><a href=\"https://developer.wordpress.org/reference/functions/is_front_page/\">is_front_page</a></code> is used directly. But for more complex logic, such as checking if the current view is a page (or even a specific page, by id), custom functions can be used (see <a href=\"https://core.trac.wordpress.org/ticket/30251\">#30251</a> for details on why this is needed). If you don&#8217;t need to support PHP 5.2, this can be done inline:\r\n\r\n<pre class=\"wp-block-code\"><code lang=\"php\" class=\"language-php \">'active_callback' =&gt; function () { return is_page(); }</code></pre>\r\n\r\nPHP 5.2 support is as simple as creating a named function and referencing it with the active_callback parameter:\r\n\r\n<pre class=\"wp-block-code\"><code lang=\"php\" class=\"language-php line-numbers\">//...\r\n'active_callback' =&gt; 'prefix_return_is_page';\r\n//...\r\nfunction prefix_return_is_page() {\r\n  return is_page();\r\n}</code></pre>\r\n\r\nWithin Custom Controls, Sections, and Panels, there is also an option to override the\u00a0<code>active_callback</code> function directly within the custom Customizer object class:\r\n\r\n<pre class=\"wp-block-code\"><code lang=\"php\" class=\"language-php line-numbers\">class WP_Customize_Greeting_Control extends WP_Customize_Control {\r\n  // ...\r\n  function active_callback() {\r\n    return is_front_page();\r\n  }\r\n}</code></pre>\r\n\r\nFinally, there is a filter that can be used to override all other\u00a0<code>active_callback</code> behavior:\r\n\r\n<pre class=\"wp-block-code\"><code lang=\"php\" class=\"language-php line-numbers\">// Hide all controls without a description when previewing single posts.\r\nfunction title_tagline_control_filter( $active, $control ) {\r\n  if ( &apos;&apos; === $control-&gt;description ) {\r\n    $active = is_singular();\r\n  }\r\n  return $active;\r\n}\r\nadd_filter( 'customize_control_active', 'title_tagline_control_filter', 10, 2 );</code></pre>\r\n\r\nNote that the\u00a0<code>active_callback</code> API works exactly the same for all of the Customizer object types (Controls, <a href=\"https://developer.wordpress.org/reference/classes/wp_customize_section/active_callback/\">Sections</a>, and <a href=\"https://developer.wordpress.org/reference/classes/wp_customize_panel/active_callback/\">Panels</a>). As an added bonus, sections will automatically be hidden if all of the controls within them are contextually hidden, and the same works for panels.\r\n<h2>Selective Refresh: Fast, Accurate Updates</h2>\r\nIntroduced in WordPress 4.5, Selective Refresh updates in\u00a0the Customizer &#8220;preview&#8221; only refresh areas whose associate settings are changed. By only updating the elements that have changed, it&#8217;s much faster and less disruptive than a full-iframe refresh. Some other benefits, as noted in <a href=\"https://make.wordpress.org/core/2016/02/16/selective-refresh-in-the-customizer\">Selective Refresh In The Customizer</a>, are:\r\n<ul>\r\n \t<li>Don&#8217;t Repeat Yourself (DRY) logic</li>\r\n \t<li>Accurate preview update</li>\r\n \t<li>Association between parts of the preview and associated settings and controls, along with\u00a0visible edit shortcuts <a href=\"https://make.wordpress.org/core/2016/11/10/visible-edit-shortcuts-in-the-customizer-preview/\">as of WordPress 4.7</a></li>\r\n</ul>\r\nThe logic in pure-JavaScript <code>postMessage</code> updates is duplicated. The JavaScript in the Customizer must mirror the PHP that produces the markup, or take shortcuts to approximate it.\u00a0But Selective Refresh is <abbr title=\"Don't Repeat Yourself\">DRY</abbr>\u00a0as there&#8217;s no duplication of JavaScript and PHP. An Ajax request retrieves the new markup for the preview.\r\n\r\nAnd because of this Ajax call, the refresh is <strong>accurate</strong>. It uses the filters that can alter the markup. It shows the same result that appears on the front end.\r\n\r\nAdditionally, selective refresh partials provide an association between areas of the preview and their corresponding settings. The customizer leverages this relationship to provide visible edit shortcuts that help users find controls associated with a particular part of their site. In the future the partials API could expand to facilitate editing settings directly within the preview and to include a structured JS API for previewing settings with partials.\r\n\r\nFor these reasons, all settings are strongly recommended to leverage selective refresh transport for improved user experience, with the option of providing additional\u00a0JavaScript-based transport\u00a0to further enhance setting previewing.\r\n<h3>Registering Partials</h3>\r\nSetting previews need to opt-in to use Selective Refresh by registering the necessary partials. In this example, largely taken from the them <a href=\"https://wordpress.org/themes/twentysixteen\">Twenty Sixteen</a>, Selective Refresh is added for the <code>blogdescription</code> setting by adding a partial with the same name.\r\n\r\n<pre class=\"wp-block-code\"><code lang=\"php\" class=\"language-php line-numbers\">function foo_theme_customize_register( WP_Customize_Manager $wp_customize ) {\r\n    $wp_customize-&gt;selective_refresh-&gt;add_partial( 'blogdescription', array(\r\n        'selector' =&gt; '.site-description',\r\n        'container_inclusive' =&gt; false,\r\n        'render_callback' =&gt; function() {\r\n            bloginfo( 'description' );\r\n        },\r\n    ) );\r\n}\r\nadd_action( 'customize_register', 'foo_theme_customize_register' );</code></pre>\r\n\r\nIf the <code>settings</code> argument is not supplied, it defaults to be the same as the partial ID, in the same way as the settings for controls default to the control ID. Here are some of the key arguments for partials:\r\n<table>\r\n<thead>\r\n<tr>\r\n<td><strong>Variable</strong></td>\r\n<td><strong>Type</strong></td>\r\n<td><strong>Description</strong></td>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr>\r\n<td><code>settings</code></td>\r\n<td>array</td>\r\n<td>Setting IDs associated with the partial.</td>\r\n</tr>\r\n<tr>\r\n<td><code>selector</code></td>\r\n<td>string</td>\r\n<td>Targets the element(s) in the page markup to be refreshed.</td>\r\n</tr>\r\n<tr>\r\n<td><code>container_inclusive</code></td>\r\n<td>boolean</td>\r\n<td>If true, a refresh replaces the entire container. Otherwise, it only replaces the container&#8217;s children. Defaults to false.</td>\r\n</tr>\r\n<tr>\r\n<td><code>render_callback</code></td>\r\n<td>function</td>\r\n<td>Produces the markup to be rendered on refresh.</td>\r\n</tr>\r\n<tr>\r\n<td><code>fallback_refresh</code></td>\r\n<td>bool</td>\r\n<td>Whether or not a full page refresh should occur if the partial is not found in the document.</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<h3>Selective Refresh JavaScript Events</h3>\r\nThese fire on <code>wp.customize.selectiveRefresh</code>:\r\n<ul>\r\n \t<li><code>partial-content-rendered</code>\r\nWhen the placement is rendered. As mentioned, JavaScript-driven widgets can re-build on this event.</li>\r\n \t<li><code>render-partials-response</code>\r\nWhen data is returned, after a request for partial rendering. The server filters this data with &#8216;customize_render_partials_response&#8217;.</li>\r\n \t<li><code>partial-content-moved</code>\r\nWhen a widget has moved in its sidebar. As shown above, JavaScript-driven widgets can refresh on this event.</li>\r\n \t<li><code>widget-updated</code>\r\nWhen the <code>WidgetPartial</code> is refreshed with its <code>renderContent</code> method.</li>\r\n \t<li><code>sidebar-updated</code>\r\nWhen a sidebar has a widget that&#8217;s refreshed or updated. Or when a sidebar&#8217;s widgets are sorted, using <code>reflowWidgets()</code>.</li>\r\n</ul>\r\n<h3>Widgets: Opting-In To Selective Refresh</h3>\r\nBoth themes and widgets <strong>need to opt-in</strong> to use Selective Refresh. All core widgets and themes have already enabled this.\r\n<h4>Theme Support In Sidebars</h4>\r\nIn order to allow partial refreshes of widgets in a theme\u2019s sidebars:\r\n\r\n<pre class=\"wp-block-code\"><code lang=\"php\" class=\"language-php \">add_theme_support( 'customize-selective-refresh-widgets' );</code></pre>\r\n\r\n<strong>Important:</strong> Selective refresh for widgets requires that the theme include a <code>before_widget</code>/<code>after_widget</code> wrapper element around each widget that contains the widget&#8217;s ID. Such wrappers are the default when you <code>register_sidebar()</code>. For example:\r\n\r\n<pre class=\"wp-block-code\"><code lang=\"php\" class=\"language-php line-numbers\">function example_widgets_init() {\r\n\tregister_sidebar(\r\n\t\tarray(\r\n\t\t\t'name'          =&gt; esc_html__( 'Sidebar', 'example' ),\r\n\t\t\t'id'            =&gt; 'sidebar-1',\r\n\t\t\t'description'   =&gt; esc_html__( 'Add widgets here.', 'example' ),\r\n\t\t\t'before_widget' =&gt; '&lt;section id=&quot;%1$s&quot; class=&quot;widget %2$s&quot;&gt;', // &lt;= Key for selective refresh.\r\n\t\t\t'after_widget'  =&gt; '&lt;/section&gt;',\r\n\t\t\t'before_title'  =&gt; '&lt;h2 class=&quot;widget-title&quot;&gt;',\r\n\t\t\t'after_title'   =&gt; '&lt;/h2&gt;',\r\n\t\t)\r\n\t);\r\n}\r\nadd_action( 'widgets_init', 'example_widgets_init' );</code></pre>\r\n\r\n<h4>Widget Support</h4>\r\nEven if a theme supports Selective Refresh, widgets also have to opt-in. All core widgets have already enabled it. Here&#8217;s an example widget adding support for Selective Refresh:\r\n\r\n<pre class=\"wp-block-code\"><code lang=\"php\" class=\"language-php line-numbers\">class Foo_Widget extends WP_Widget {\r\n\r\n    public function __construct() {\r\n        parent::__construct(\r\n            \u2018foo\u2019,\r\n            __( 'Example', 'bar-plugin' ),\r\n            array(\r\n                'description' =&gt; __( \u2018An example widget\u2019, \u2018bar-plugin\u2019 ),\r\n                'customize_selective_refresh' =&gt; true,\r\n            )\r\n        );\r\n\r\n        if ( is_active_widget( false, false, $this-&gt;id_base ) || is_customize_preview() ) {\r\n            add_action( 'wp_enqueue_scripts', array( $this, 'enqueue_scripts' ) );\r\n        }\r\n    }\r\n    ...</code></pre>\r\n\r\nLine 9 above enables Selective Refresh:\r\n\r\n<pre class=\"wp-block-code\"><code lang=\"php\" class=\"language-php \">'customize_selective_refresh' =&gt; true,</code></pre>\r\n\r\nLine 13 above ensures the widget&#8217;s stylesheet always appears in Customizer sessions. Adding the widget won&#8217;t cause a full-page refresh to retrieve the styling:\r\n\r\n<pre class=\"wp-block-code\"><code lang=\"php\" class=\"language-php \">if ( is_active_widget( false, false, $this-&gt;id_base ) || is_customize_preview() ) {\r\n    add_action( 'wp_enqueue_scripts', array( $this, 'enqueue_scripts' ) );\r\n}</code></pre>\r\n\r\nSee <a href=\"https://make.wordpress.org/core/2016/03/22/implementing-selective-refresh-support-for-widgets/\">Implementing Selective Refresh Support for Widgets</a>.\r\n<h4>JavaScript-Driven Widget Support</h4>\r\nWidgets that rely on JavaScript for their markup will need additional steps, as shown in <a href=\"https://make.wordpress.org/core/2016/03/22/implementing-selective-refresh-support-for-widgets/\">Implementing Selective Refresh Support for Widgets</a>:\r\n<ol>\r\n<ol>\r\n \t<li>Enqueue any JavaScript files based on <code>is_customize_preview()</code>, as shown above for stylesheets.</li>\r\n \t<li>Add a handler for the <code>partial-content-rendered</code> event, and refresh the widget as needed:</li>\r\n</ol>\r\n</ol>\r\n\r\n<pre class=\"wp-block-code\"><code lang=\"js\" class=\"language-js \">wp.customize.selectiveRefresh.bind( 'partial-content-rendered', function( placement ) {\r\n    // logic to refresh\r\n} );</code></pre>\r\n\r\n<ol>\r\n<ol>\r\n \t<li>If the widget includes an iframe, add a handler to refresh the partial:</li>\r\n</ol>\r\n</ol>\r\n\r\n<pre class=\"wp-block-code\"><code lang=\"js\" class=\"language-js \">wp.customize.selectiveRefresh.bind( 'partial-content-moved', function( placement ) {\r\n    // logic to refresh, perhaps conditionally\r\n}</code></pre>\r\n\r\n<h2>Using PostMessage For Improved Setting Previewing</h2>\r\nThe Customizer automatically handles previewing all settings out-of-the-box. This is done by silently reloading the entire preview window, with settings being filtered by PHP in that Ajax call. While this works just fine, it can be very slow since the entire front-end must be reloaded for every\u00a0single setting change. Selective Refresh improves this experience by refreshing only the elements that have changed, but due to the Ajax call, there is still a delay in seeing the changes in the preview.\r\n\r\nTo further improve the\u00a0user experience, the Customizer offers an API for managing setting changes directly in JavaScript, allowing for truly-live previewing. The below images show a comparison of a Custom CSS option that leverages this technology, called <code>postMessage</code>, versus\u00a0the standard refresh option:\r\n\r\n<figure style=\"width: 282px\" class=\"wp-caption alignright\"><img loading=\"lazy\" decoding=\"async\" class=\"\"  src=\"//i1.wp.com/nick.halsey.co/wp-content/uploads/sites/2/2014/08/customize-setting-postmessage.gif\" alt=\"\" width=\"282\" height=\"260\" /><figcaption class=\"wp-caption-text\">Custom CSS setting in the Customizer with the postMessage setting transport.</figcaption></figure>\r\n\r\n<figure style=\"width: 281px\" class=\"wp-caption alignnone\"><img loading=\"lazy\" decoding=\"async\" class=\"\"  src=\"//i1.wp.com/nick.halsey.co/wp-content/uploads/sites/2/2014/08/customize-setting-refresh-1.gif\" alt=\"\" width=\"281\" height=\"266\" /><figcaption class=\"wp-caption-text\">Custom CSS setting in the Customizer with the default refresh setting transport.</figcaption></figure>\r\n\r\nTo use postMessage, first set the transport parameter to postMessage when adding your setting. Many themes also modify core settings such as the title and tagline to leverage postMessage by modifying the transport property of those settings:\r\n\r\n<pre class=\"wp-block-code\"><code lang=\"php\" class=\"language-php \">$wp_customize-&gt;get_setting( 'blogname' )-&gt;transport        = 'postMessage';\r\n$wp_customize-&gt;get_setting( 'blogdescription' )-&gt;transport = 'postMessage';</code></pre>\r\n\r\nOnce the setting&#8217;s transport is set to postMessage, the setting will no longer trigger a refresh of the preview when its value changes. To implement the JavaScript to update the setting within the preview of the front-end, first create and enqueue a JavaScript file:\r\n\r\n<pre class=\"wp-block-code\"><code lang=\"php\" class=\"language-php \">function my_preview_js() {\r\n  wp_enqueue_script( 'custom_css_preview', 'path/to/file.js', array( 'customize-preview', 'jquery' ) );\r\n}\r\nadd_action( 'customize_preview_init', 'my_preview_js' );</code></pre>\r\n\r\nYour JavaScript file should look something like this:\r\n\r\n<pre class=\"wp-block-code\"><code lang=\"js\" class=\"language-js line-numbers\">( function( $ ) {\r\n  wp.customize( 'setting_id', function( value ) {\r\n    value.bind( function( to ) {\r\n      $( '#custom-theme-css' ).html( to );\r\n    } );\r\n  } );\r\n  wp.customize( 'custom_plugin_css', function( value ) {\r\n    value.bind( function( to ) {\r\n      $( '#custom-plugin-css' ).html( to );\r\n    } );\r\n  } );\r\n} )( jQuery );</code></pre>\r\n\r\nNote that you don&#8217;t necessarily need to be great with JavaScript to use postMessage &#8211; most of the code is boilerplate. The types of settings that benefit most from postMessage transport require simple JS changes such as using jQuery&#8217;s .html() or .text() methods, or swapping out a class on the <code>&lt;body&gt;</code> or another element to trigger a different set of CSS rules. Doing this, or\u00a0simplifying the instant preview logic with fully-accurate changes updating with selective refresh, the user experience can be fast without duplicating all of the PHP logic in JS.\r\n<h2>Setting Validation</h2>\r\nWordPress 4.6 includes\u00a0new APIs related to validation of Customizer setting values. The Customizer has had\u00a0sanitization of setting\u00a0values since it was introduced. Sanitization involves coercing a value into something safe to persist to the database: common examples are converting a value into an integer or stripping tags from some text input. As such, sanitization\u00a0is a <em>lossy</em> operation.\u00a0With the addition of setting validation:\r\n<ol>\r\n \t<li>All modified settings are\u00a0validated up-front\u00a0before any of them are saved.</li>\r\n \t<li>If\u00a0any setting is invalid, the Customizer\u00a0save request is rejected: a save thus becomes <em>transactional</em>\u00a0with all\u00a0the settings left dirty to try saving again.\u00a0(The Customizer\u00a0<a href=\"https://make.wordpress.org/core/2015/01/26/customizer-transactions-proposal/\">transactions proposal</a>\u00a0is closely related to setting\u00a0validation here.)</li>\r\n \t<li>Validation error messages are\u00a0displayed\u00a0to the user, prompting them to fix their mistake and try again.</li>\r\n</ol>\r\nSanitization and validation are also both part of the REST API infrastructure via <code>WP_REST_Request::sanitize_params()</code>\u00a0and <code>WP_REST_Request::validate_params()</code>, respectively. A\u00a0setting&#8217;s value goes through validation before it goes through sanitization.\r\n\r\nFor more information on the validation behavior, and additional code examples, see <a href=\"https://make.wordpress.org/core/2016/07/05/customizer-apis-in-4-6-for-setting-validation-and-notifications/\">the feature announcement post</a>.\r\n<h3>Validating Settings\u00a0in PHP</h3>\r\nJust as you can supply a <code>sanitize_callback</code>\u00a0when registering\u00a0a setting, you can also supply\u00a0a <code>validate_callback</code>\u00a0arg:\r\n\r\n<pre class=\"wp-block-code\"><code lang=\"php\" class=\"language-php line-numbers\">$wp_customize-&gt;add_setting( 'established_year', array(\r\n    'sanitize_callback' =&gt; 'absint',\r\n    'validate_callback' =&gt; 'validate_established_year'\r\n) );\r\nfunction validate_established_year( $validity, $value ) {\r\n    $value = intval( $value );\r\n    if ( empty( $value ) || ! is_numeric( $value ) ) {\r\n        $validity-&gt;add( 'required', __( 'You must supply a valid year.' ) );\r\n    } elseif ( $value &amp;lt; 1900 ) {\r\n        $validity-&gt;add( 'year_too_small', __( 'Year is too old.' ) );\r\n    } elseif ( $value &gt; gmdate( 'Y' ) ) {\r\n        $validity-&gt;add( 'year_too_big', __( 'Year is too new.' ) );\r\n    }\r\n    return $validity;\r\n}</code></pre>\r\n\r\nJust as supplying a <code>sanitize_callback</code>\u00a0arg adds a filter for <code>customize_sanitize_{$setting_id}</code>, so too supplying a <code>validate_callback</code>\u00a0arg will add a filter for <code>customize_validate_{$setting_id}</code>. Assuming that the <code>WP_Customize_Setting</code>\u00a0instances apply filters on these in their <code>validate</code>\u00a0methods,\u00a0you can add this\u00a0filter if you need to add validation for settings that have been previously added.\r\n\r\nThe <code>validate_callback</code> and any <code>customize_validate_{$setting_id}</code> filter callbacks take a <code>WP_Error</code> instance is its first argument (which initially is empty of any errors added), followed by the <code>$value</code> being sanitized, and lastly the <code>WP_Customize_Setting</code> instance that is being validated.\r\n\r\nCustom setting classes can also override the <code>validate </code>method of the setting class directly.\r\n<h3>Client-side Validation</h3>\r\nIf\u00a0you have a setting that is previewed purely via JavaScript (and the <code>postMessage</code> transport <em>without</em> selective refresh), you should also add client-side validation.\u00a0Otherwise, any validation errors will persist until a full refresh happens or a save is attempted. Client-side validation must not take the place of server-side validation, since malicious users could bypass the client-side validation to save an invalid value if corresponding server-side validation is not in place.\r\n\r\nThere is a <code>validate</code> method available on the <code>wp.customize.Setting</code> JS class (actually, the <code>wp.customize.Value</code> base class). Its\u00a0name is a bit misleading, as it actually behaves very similarly to the <code>WP_Customize_Setting::sanitize()</code> PHP method, but it can be used to both sanitize and validate a value in JS. Note that this JS runs in the context of the Customizer <em>pane</em> not the preview, so any such JS should have <code>customize-controls</code> as a dependency (not <code>customize-preview</code>) and enqueued during the <code>customize_controls_enqueue_scripts</code> action. Some example JS validation:\r\n\r\n<pre class=\"wp-block-code\"><code lang=\"js\" class=\"language-js line-numbers\">wp.customize( 'established_year', function ( setting ) {\r\n\tsetting.validate = function ( value ) {\r\n\t\tvar code, notification;\r\n\t\tvar year = parseInt( value, 10 );\r\n\r\n\t\tcode = 'required';\r\n\t\tif ( isNaN( year ) ) {\r\n\t\t\tnotification = new wp.customize.Notification( code, {message: myPlugin.l10n.yearRequired} );\r\n\t\t\tsetting.notifications.add( code, notification );\r\n\t\t} else {\r\n\t\t\tsetting.notifications.remove( code );\r\n\t\t}\r\n\r\n\t\tcode = 'year_too_small';\r\n\t\tif ( year &amp;lt; 1900 ) {\r\n\t\t\tnotification = new wp.customize.Notification( code, {message: myPlugin.l10n.yearTooSmall} );\r\n\t\t\tsetting.notifications.add( code, notification );\r\n\t\t} else {\r\n\t\t\tsetting.notifications.remove( code );\r\n\t\t}\r\n\r\n\t\tcode = 'year_too_big';\r\n\t\tif ( year &gt; new Date().getFullYear() ) {\r\n\t\t\tnotification = new wp.customize.Notification( code, {message: myPlugin.l10n.yearTooBig} );\r\n\t\t\tsetting.notifications.add( code, notification );\r\n\t\t} else {\r\n\t\t\tsetting.notifications.remove( code );\r\n\t\t}\r\n\r\n\t\treturn value;\r\n\t};\r\n} );</code></pre>\r\n\r\n<h2>Notifications</h2>\r\n<img data-recalc-dims=\"1\" loading=\"lazy\" decoding=\"async\" class=\"size-medium wp-image-18662 alignright\" src=\"https://i0.wp.com/make.wordpress.org/core/files/2016/07/error-notification-300x112.png?resize=300%2C112&#038;ssl=1\" alt=\"Error notification\" width=\"300\" height=\"112\" />Notifications provide user feedback, typically based on the value of a control&#8217;s setting. An error notification is added to a setting&#8217;s <code>notifications</code> collection when a setting&#8217;s validation routine returns a <code>WP_Error</code> instance. Each error added to a PHP <code>WP_Error</code> instance is represented as a <code>wp.customize.Notification</code> in JavaScript:\r\n<ul>\r\n \t<li>A <code>WP_Error</code>&#8216;s <code>code</code> is available as <code>notification.code</code> in JS.</li>\r\n \t<li>A <code>WP_Error</code>&#8216;s <code>message</code> is available as <code>notification.message</code> in JS. Note that if there are multiple messages added to a given error code in PHP they will be concatenated into a single message in JS.</li>\r\n \t<li>A <code>WP_Error</code>&#8216;s <code>data</code> is available as <code>notification.data</code> in JS. This is useful to pass additional error context from the server to the client.</li>\r\n</ul>\r\nAny time that a <code>WP_Error</code> is returned from a validation routine on the server it will result in a <code>wp.customize.Notification</code> being created with a <code>type</code> property of \u201cerror\u201d.\r\n\r\nWhile setting non-error notifications from PHP is not currently supported (see #37281), you can also add non-error notifications with JS as follows:\r\n\r\n<pre class=\"wp-block-code\"><code lang=\"js\" class=\"language-js line-numbers\">wp.customize( 'blogname', function( setting ) {\r\n    setting.bind( function( value ) {\r\n        var code = 'long_title';\r\n        if ( value.length &gt; 20 ) {\r\n            setting.notifications.add( code, new wp.customize.Notification(\r\n                code,\r\n                {\r\n                    type: 'warning',\r\n                    message: 'This theme prefers title with max 20 chars.'\r\n                }\r\n            ) );\r\n        } else {\r\n            setting.notifications.remove( code );\r\n        }\r\n    } );\r\n} );</code></pre>\r\n\r\nYou can also supply \u201cinfo\u201d as a notification&#8217;s <code>type</code>. The default <code>type</code> is \u201cerror\u201d. Custom types may also be supplied, and the notifications can be styled with CSS selector matching <code>notice.notice-foo</code> where \u201cfoo\u201d is the type supplied. A control may also override the default behavior for how notifications are rendered by overriding the <code>wp.customize.Control.renderNotifications</code> method.",
        "protected": false
    },
    "author": 9362879,
    "featured_media": 0,
    "parent": 11390,
    "menu_order": 1,
    "template": "",
    "meta": {
        "footnotes": ""
    },
    "class_list": [
        "post-25005",
        "theme-handbook",
        "type-theme-handbook",
        "status-publish",
        "hentry",
        "type-handbook"
    ],
    "revision_note": "",
    "jetpack_sharing_enabled": true,
    "_links": {
        "self": [
            {
                "href": "https://developer.wordpress.org/wp-json/wp/v2/theme-handbook/25005",
                "targetHints": {
                    "allow": [
                        "GET"
                    ]
                }
            }
        ],
        "collection": [
            {
                "href": "https://developer.wordpress.org/wp-json/wp/v2/theme-handbook"
            }
        ],
        "about": [
            {
                "href": "https://developer.wordpress.org/wp-json/wp/v2/types/theme-handbook"
            }
        ],
        "author": [
            {
                "embeddable": true,
                "href": "https://developer.wordpress.org/wp-json/wp/v2/users/9362879"
            }
        ],
        "version-history": [
            {
                "count": 3,
                "href": "https://developer.wordpress.org/wp-json/wp/v2/theme-handbook/25005/revisions"
            }
        ],
        "predecessor-version": [
            {
                "id": 30387,
                "href": "https://developer.wordpress.org/wp-json/wp/v2/theme-handbook/25005/revisions/30387"
            }
        ],
        "up": [
            {
                "embeddable": true,
                "href": "https://developer.wordpress.org/wp-json/wp/v2/theme-handbook/11390"
            }
        ],
        "wp:attachment": [
            {
                "href": "https://developer.wordpress.org/wp-json/wp/v2/media?parent=25005"
            }
        ],
        "curies": [
            {
                "name": "wp",
                "href": "https://api.w.org/{rel}",
                "templated": true
            }
        ]
    }
}