{
    "id": 134546,
    "date": "2021-03-09T08:38:23",
    "date_gmt": "2021-03-09T08:38:23",
    "guid": {
        "rendered": "https://developer.wordpress.org/block-editor/reference-guides/packages/packages-data/"
    },
    "modified": "2024-12-18T16:04:13",
    "modified_gmt": "2024-12-18T16:04:13",
    "slug": "packages-data",
    "status": "publish",
    "type": "blocks-handbook",
    "link": "https://developer.wordpress.org/block-editor/reference-guides/packages/packages-data/",
    "title": {
        "rendered": "@wordpress/data"
    },
    "content": {
        "rendered": "<p>WordPress&#8217; data module serves as a hub to manage application state for both plugins and WordPress itself, providing tools to manage data within and between distinct modules. It is designed as a modular pattern for organizing and sharing data: simple enough to satisfy the needs of a small plugin, while scalable to serve the requirements of a complex single-page application.</p>\n<p>The data module is built upon and shares many of the same core principles of <a href=\"https://redux.js.org/\">Redux</a>, but shouldn&#8217;t be mistaken as merely <em>Redux for WordPress</em>, as it includes a few of its own <a href=\"#comparison-with-redux\">distinguishing characteristics</a>. As you read through this guide, you may find it useful to reference the Redux documentation \u2014 particularly <a href=\"https://redux.js.org/glossary\">its glossary</a> \u2014 for more detail on core concepts.</p>\n<h2>Installation</h2>\n<p>Install the module</p>\n<pre><code class=\"language-bash\">npm install @wordpress/data --save\n</code></pre>\n<p><em>This package assumes that your code will run in an <strong>ES2015+</strong> environment. If you&#8217;re using an environment that has limited or no support for such language features and APIs, you should include <a href=\"https://github.com/WordPress/gutenberg/tree/HEAD/packages/babel-preset-default#polyfill\">the polyfill shipped in <code>@wordpress/babel-preset-default</code></a> in your code.</em></p>\n<h2>Registering a Store</h2>\n<p>Use the <code>register</code> function to add your own store to the centralized data registry. This function accepts one argument \u2013 a store descriptor that can be created with <code>createReduxStore</code> factory function. <code>createReduxStore</code> accepts two arguments: a name to identify the module, and a configuration object with values describing how your state is represented, modified, and accessed. At a minimum, you must provide a reducer function describing the shape of your state and how it changes in response to actions dispatched to the store.</p>\n<pre><code class=\"language-js\">import apiFetch from '@wordpress/api-fetch';\nimport { createReduxStore, register } from '@wordpress/data';\n\nconst DEFAULT_STATE = {\n    prices: {},\n    discountPercent: 0,\n};\n\nconst actions = {\n    setPrice( item, price ) {\n        return {\n            type: 'SET_PRICE',\n            item,\n            price,\n        };\n    },\n\n    startSale( discountPercent ) {\n        return {\n            type: 'START_SALE',\n            discountPercent,\n        };\n    },\n};\n\nconst store = createReduxStore( 'my-shop', {\n    reducer( state = DEFAULT_STATE, action ) {\n        switch ( action.type ) {\n            case 'SET_PRICE':\n                return {\n                    ...state,\n                    prices: {\n                        ...state.prices,\n                        [ action.item ]: action.price,\n                    },\n                };\n\n            case 'START_SALE':\n                return {\n                    ...state,\n                    discountPercent: action.discountPercent,\n                };\n        }\n\n        return state;\n    },\n\n    actions,\n\n    selectors: {\n        getPrice( state, item ) {\n            const { prices, discountPercent } = state;\n            const price = prices[ item ];\n\n            return price * ( 1 - 0.01 * discountPercent );\n        },\n    },\n\n    resolvers: {\n        getPrice: ( item ) =&gt; async ({ dispatch }) =&gt; { {\n            const path = '/wp/v2/prices/' + item;\n            const price = await apiFetch( { path } );\n            dispatch.setPrice( item, price );\n        },\n    },\n} );\n\nregister( store );\n</code></pre>\n<p>The return value of <code>createReduxStore</code> is the <code>StoreDescriptor</code> object that contains two properties:</p>\n<ul>\n<li><code>name</code> (<code>string</code>) \u2013 the name of the store</li>\n<li><code>instantiate</code> (<code>Function</code>) &#8211; it returns a <a href=\"https://redux.js.org/basics/store\">Redux-like store object</a> with the following methods:\n<ul>\n<li><code>getState()</code>: Returns the state value of the registered reducer\n<ul>\n<li><em>Redux parallel:</em> <a href=\"https://redux.js.org/api/store#getstate\"><code>getState</code></a></li>\n</ul>\n</li>\n<li><code>subscribe( listener: Function )</code>: Registers a function called any time the value of state changes.\n<ul>\n<li><em>Redux parallel:</em> <a href=\"https://redux.js.org/api/store#subscribelistener\"><code>subscribe</code></a></li>\n</ul>\n</li>\n<li><code>dispatch( action: Object )</code>: Given an action object, calls the registered reducer and updates the state value.\n<ul>\n<li><em>Redux parallel:</em> <a href=\"https://redux.js.org/api/store#dispatchaction\"><code>dispatch</code></a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3>Redux Store Options</h3>\n<h4><code>reducer</code></h4>\n<p>A <a href=\"https://redux.js.org/basics/reducers\"><strong>reducer</strong></a> is a function accepting the previous <code>state</code> and <code>action</code> as arguments and returns an updated <code>state</code> value.</p>\n<h4><code>actions</code></h4>\n<p>The <strong><code>actions</code></strong> object should describe all <a href=\"https://redux.js.org/glossary#action-creator\">action creators</a> available for your store. An action creator is a function that optionally accepts arguments and returns an action object to dispatch to the registered reducer. <em>Dispatching actions is the primary mechanism for making changes to your state.</em></p>\n<h4><code>selectors</code></h4>\n<p>The <strong><code>selectors</code></strong> object includes a set of functions for accessing and deriving state values. A selector is a function which accepts state and optional arguments and returns some value from state. <em>Calling selectors is the primary mechanism for retrieving data from your state</em>, and serve as a useful abstraction over the raw data which is typically more susceptible to change and less readily usable as a <a href=\"https://redux.js.org/recipes/structuring-reducers/normalizing-state-shape#designing-a-normalized-state\">normalized object</a>.</p>\n<h4><code>resolvers</code></h4>\n<p>A <strong>resolver</strong> is a side-effect for a selector. If your selector result may need to be fulfilled from an external source, you can define a resolver such that the first time the selector is called, the fulfillment behavior is effected.</p>\n<p>The <code>resolvers</code> option should be passed as an object where each key is the name of the selector to act upon, the value a function which receives the same arguments passed to the selector, excluding the state argument. It can then dispatch as necessary to fulfill the requirements of the selector, taking advantage of the fact that most data consumers will subscribe to subsequent state changes (by <code>subscribe</code> or <code>withSelect</code>).</p>\n<p>Resolvers, in combination with <a href=\"https://github.com/WordPress/gutenberg/blob/trunk/docs/how-to-guides/thunks.md#thunks-can-be-async\">thunks</a>, can be used to implement asynchronous data flows for your store.</p>\n<h4><code>controls</code> (deprecated)</h4>\n<p>To handle asynchronous data flows, it is recommended to use <a href=\"https://github.com/WordPress/gutenberg/blob/trunk/docs/how-to-guides/thunks.md#thunks-can-be-async\">thunks</a> instead of <code>controls</code>.</p>\n<details>\n<summary>View <em>controls</em> explanation</summary>\n<p>\nA <em>control</em> defines the execution flow behavior associated with a specific action type. Before <a href=\"https://github.com/WordPress/gutenberg/blob/trunk/docs/how-to-guides/thunks.md#thunks-can-be-async\">thunks</a>, controls were used to implement asynchronous data flows for your store. By defining your action creator or resolvers as a generator which yields specific controlled action types, the execution will proceed as defined by the control handler.</p>\n<p>The <em>controls</em> option should be passed as an object where each key is the name of the action type to act upon, the value a function which receives the original action object. It should returns either a promise which is to resolve when evaluation of the action should continue, or a value. The value or resolved promise value is assigned on the return value of the yield assignment. If the control handler returns undefined, the execution is not continued.</p>\n<p>Refer to the <a href=\"https://github.com/WordPress/gutenberg/tree/HEAD/packages/redux-routine/README.md\">documentation of <em>@wordpress/redux-routine</em></a> for more information.<br />\n</details>\n<h4><code>initialState</code></h4>\n<p>An optional preloaded initial state for the store. You may use this to restore some serialized state value or a state generated server-side.</p>\n<h2>Generic Stores</h2>\n<p>The <code>@wordpress/data</code> module offers a more advanced and generic interface for the purposes of integrating other data systems and situations where more direct control over a data system is needed. In this case, a data store will need to be implemented outside of <code>@wordpress/data</code> and then plugged in via three functions:</p>\n<ul>\n<li><code>getSelectors()</code>: Returns an object of selector functions, pre-mapped to the store.</li>\n<li><code>getActions()</code>: Returns an object of action functions, pre-mapped to the store.</li>\n<li><code>subscribe( listener: Function )</code>: Registers a function called any time the value of state changes.\n<ul>\n<li>Behaves as Redux <a href=\"https://redux.js.org/api/store#subscribelistener\"><code>subscribe</code></a><br />\nwith the following differences:</p>\n<ul>\n<li>Doesn&#8217;t have to implement an unsubscribe, since the registry never uses it.<br />\n&#045; Only has to support one listener (the registry).</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>By implementing the above interface for your custom store, you gain the benefits of using the registry and the <code>withSelect</code> and <code>withDispatch</code> higher order components in your application code. This provides seamless integration with existing and alternative data systems.</p>\n<p>Integrating an existing redux store with its own reducers, store enhancers and middleware can be accomplished as follows:</p>\n<p><em>Example:</em></p>\n<pre><code class=\"language-js\">import { register } from '@wordpress/data';\nimport existingSelectors from './existing-app/selectors';\nimport existingActions from './existing-app/actions';\nimport createStore from './existing-app/store';\n\nconst reduxStore = createStore();\n\nconst mapValues = ( obj, callback ) =&gt;\n    Object.entries( obj ).reduce(\n        ( acc, [ key, value ] ) =&gt; ( {\n            ...acc,\n            [ key ]: callback( value ),\n        } ),\n        {}\n    );\n\nconst boundSelectors = mapValues(\n    existingSelectors,\n    ( selector ) =&gt;\n        ( ...args ) =&gt;\n            selector( reduxStore.getState(), ...args )\n);\n\nconst boundActions = mapValues(\n    existingActions,\n    ( action ) =&gt;\n        ( ...args ) =&gt;\n            reduxStore.dispatch( action( ...args ) )\n);\n\nconst genericStore = {\n    name: 'existing-app',\n    instantiate: () =&gt; ( {\n        getSelectors: () =&gt; boundSelectors,\n        getActions: () =&gt; boundActions,\n        subscribe: reduxStore.subscribe,\n    } ),\n};\n\nregister( genericStore );\n</code></pre>\n<p>It is also possible to implement a completely custom store from scratch:</p>\n<p><em>Example:</em></p>\n<pre><code class=\"language-js\">import { register } from '@wordpress/data';\n\nfunction customStore() {\n    return {\n        name: 'custom-data',\n        instantiate: () =&gt; {\n            const listeners = new Set();\n            const prices = { hammer: 7.5 };\n\n            function storeChanged() {\n                for ( const listener of listeners ) {\n                    listener();\n                }\n            }\n\n            function subscribe( listener ) {\n                listeners.add( listener );\n                return () =&gt; listeners.delete( listener );\n            }\n\n            const selectors = {\n                getPrice( itemName ) {\n                    return prices[ itemName ];\n                },\n            };\n\n            const actions = {\n                setPrice( itemName, price ) {\n                    prices[ itemName ] = price;\n                    storeChanged();\n                },\n            };\n\n            return {\n                getSelectors: () =&gt; selectors,\n                getActions: () =&gt; actions,\n                subscribe,\n            };\n        },\n    };\n}\n\nregister( customStore );\n</code></pre>\n<h2>Comparison with Redux</h2>\n<p>The data module shares many of the same <a href=\"https://redux.js.org/introduction/three-principles\">core principles</a> and <a href=\"https://redux.js.org/api/api-reference\">API method naming</a> of <a href=\"https://redux.js.org/\">Redux</a>. In fact, it is implemented atop Redux. Where it differs is in establishing a modularization pattern for creating separate but interdependent stores, and in codifying conventions such as selector functions as the primary entry point for data access.</p>\n<p>The <a href=\"#higher-order-components\">higher-order components</a> were created to complement this distinction. The intention with splitting <code>withSelect</code> and <code>withDispatch</code> \u2014 where in React Redux they are combined under <code>connect</code> as <code>mapStateToProps</code> and <code>mapDispatchToProps</code> arguments \u2014 is to more accurately reflect that dispatch is not dependent upon a subscription to state changes, and to allow for state-derived values to be used in <code>withDispatch</code> (via <a href=\"https://github.com/WordPress/gutenberg/tree/HEAD/packages/compose/README.md\">higher-order component composition</a>).</p>\n<p>The data module also has built-in solutions for handling asynchronous side-effects, through <a href=\"#resolvers\">resolvers</a> and <a href=\"https://github.com/WordPress/gutenberg/blob/trunk/docs/how-to-guides/thunks.md#thunks-can-be-async\">thunks</a>. These differ slightly from <a href=\"https://redux.js.org/advanced/async-actions\">standard redux async solutions</a> like <a href=\"https://github.com/gaearon/redux-thunk\"><code>redux-thunk</code></a> or <a href=\"https://redux-saga.js.org/\"><code>redux-saga</code></a>.</p>\n<p>Specific implementation differences from Redux and React Redux:</p>\n<ul>\n<li>In Redux, a <code>subscribe</code> listener is called on every dispatch, regardless of whether the value of state has changed.\n<ul>\n<li>In <code>@wordpress/data</code>, a subscriber is only called when state has changed.</li>\n</ul>\n</li>\n<li>In React Redux, a <code>mapStateToProps</code> function must return an object.\n<ul>\n<li>In <code>@wordpress/data</code>, a <code>withSelect</code> mapping function can return <code>undefined</code> if it has no props to inject.</li>\n</ul>\n</li>\n<li>In React Redux, the <code>mapDispatchToProps</code> argument can be defined as an object or a function.\n<ul>\n<li>In <code>@wordpress/data</code>, the <code>withDispatch</code> higher-order component creator must be passed a function.</li>\n</ul>\n</li>\n</ul>\n<h2>API</h2>\n<p><!-- START TOKEN(Autogenerated API docs) --></p>\n<h3>AsyncModeProvider</h3>\n<p>Context Provider Component used to switch the data module component rerendering between Sync and Async modes.</p>\n<p><em>Usage</em></p>\n<pre><code class=\"language-js\">import { useSelect, AsyncModeProvider } from '@wordpress/data';\nimport { store as blockEditorStore } from '@wordpress/block-editor';\n\nfunction BlockCount() {\n    const count = useSelect( ( select ) =&gt; {\n        return select( blockEditorStore ).getBlockCount();\n    }, [] );\n\n    return count;\n}\n\nfunction App() {\n    return (\n        &lt;AsyncModeProvider value={ true }&gt;\n            &lt;BlockCount /&gt;\n        &lt;/AsyncModeProvider&gt;\n    );\n}\n</code></pre>\n<p>In this example, the BlockCount component is rerendered asynchronously.<br />\nIt means if a more critical task is being performed (like typing in an input),<br />\nthe rerendering is delayed until the browser becomes IDLE.<br />\nIt is possible to nest multiple levels of AsyncModeProvider to fine-tune the rendering behavior.</p>\n<p><em>Parameters</em></p>\n<ul>\n<li><em>props.value</em> <code>boolean</code>: Enable Async Mode.</li>\n</ul>\n<p><em>Returns</em></p>\n<ul>\n<li><code>Component</code>: The component to be rendered.</li>\n</ul>\n<h3>combineReducers</h3>\n<p>The combineReducers helper function turns an object whose values are different reducing functions into a single reducing function you can pass to registerReducer.</p>\n<p><em>Usage</em></p>\n<pre><code class=\"language-js\">import { combineReducers, createReduxStore, register } from '@wordpress/data';\n\nconst prices = ( state = {}, action ) =&gt; {\n    return action.type === 'SET_PRICE'\n        ? {\n                ...state,\n                [ action.item ]: action.price,\n          }\n        : state;\n};\n\nconst discountPercent = ( state = 0, action ) =&gt; {\n    return action.type === 'START_SALE' ? action.discountPercent : state;\n};\n\nconst store = createReduxStore( 'my-shop', {\n    reducer: combineReducers( {\n        prices,\n        discountPercent,\n    } ),\n} );\nregister( store );\n</code></pre>\n<p><em>Type</em></p>\n<ul>\n<li><code>import('./types').combineReducers</code></li>\n</ul>\n<p><em>Parameters</em></p>\n<ul>\n<li><em>reducers</em> <code>Object</code>: An object whose values correspond to different reducing functions that need to be combined into one.</li>\n</ul>\n<p><em>Returns</em></p>\n<ul>\n<li><code>Function</code>: A reducer that invokes every reducer inside the reducers object, and constructs a state object with the same shape.</li>\n</ul>\n<h3>controls</h3>\n<p>Undocumented declaration.</p>\n<h3>createReduxStore</h3>\n<p>Creates a data store descriptor for the provided Redux store configuration containing properties describing reducer, actions, selectors, controls and resolvers.</p>\n<p><em>Usage</em></p>\n<pre><code class=\"language-js\">import { createReduxStore } from '@wordpress/data';\n\nconst store = createReduxStore( 'demo', {\n    reducer: ( state = 'OK' ) =&gt; state,\n    selectors: {\n        getValue: ( state ) =&gt; state,\n    },\n} );\n</code></pre>\n<p><em>Parameters</em></p>\n<ul>\n<li><em>key</em> <code>string</code>: Unique namespace identifier.</li>\n<li><em>options</em> <code>ReduxStoreConfig&lt;State,Actions,Selectors&gt;</code>: Registered store options, with properties describing reducer, actions, selectors, and resolvers.</li>\n</ul>\n<p><em>Returns</em></p>\n<ul>\n<li><code>StoreDescriptor&lt;ReduxStoreConfig&lt;State,Actions,Selectors&gt;&gt;</code>: Store Object.</li>\n</ul>\n<h3>createRegistry</h3>\n<p>Creates a new store registry, given an optional object of initial store configurations.</p>\n<p><em>Parameters</em></p>\n<ul>\n<li><em>storeConfigs</em> <code>Object</code>: Initial store configurations.</li>\n<li><em>parent</em> <code>?Object</code>: Parent registry.</li>\n</ul>\n<p><em>Returns</em></p>\n<ul>\n<li><code>WPDataRegistry</code>: Data registry.</li>\n</ul>\n<h3>createRegistryControl</h3>\n<p>Creates a control function that takes additional curried argument with the <code>registry</code> object. While a regular control has signature</p>\n<pre><code class=\"language-js\">( action ) =&gt; iteratorOrPromise;\n</code></pre>\n<p>where the control works with the <code>action</code> that it&#8217;s bound to, a registry control has signature:</p>\n<pre><code class=\"language-js\">( registry ) =&gt; ( action ) =&gt; iteratorOrPromise;\n</code></pre>\n<p>A registry control is typically used to select data or dispatch an action to a registered store.</p>\n<p>When registering a control created with <code>createRegistryControl</code> with a store, the store knows which calling convention to use when executing the control.</p>\n<p><em>Parameters</em></p>\n<ul>\n<li><em>registryControl</em> <code>T &amp; { isRegistryControl?: boolean; }</code>: Function receiving a registry object and returning a control.</li>\n</ul>\n<p><em>Returns</em></p>\n<ul>\n<li>Registry control that can be registered with a store.</li>\n</ul>\n<h3>createRegistrySelector</h3>\n<p>Creates a selector function that takes additional curried argument with the registry <code>select</code> function. While a regular selector has signature</p>\n<pre><code class=\"language-js\">( state, ...selectorArgs ) =&gt; result;\n</code></pre>\n<p>that allows to select data from the store&#8217;s <code>state</code>, a registry selector has signature:</p>\n<pre><code class=\"language-js\">( select ) =&gt;\n    ( state, ...selectorArgs ) =&gt;\n        result;\n</code></pre>\n<p>that supports also selecting from other registered stores.</p>\n<p><em>Usage</em></p>\n<pre><code class=\"language-js\">import { store as coreStore } from '@wordpress/core-data';\nimport { store as editorStore } from '@wordpress/editor';\n\nconst getCurrentPostId = createRegistrySelector( ( select ) =&gt; ( state ) =&gt; {\n    return select( editorStore ).getCurrentPostId();\n} );\n\nconst getPostEdits = createRegistrySelector( ( select ) =&gt; ( state ) =&gt; {\n    // calling another registry selector just like any other function\n    const postType = getCurrentPostType( state );\n    const postId = getCurrentPostId( state );\n    return select( coreStore ).getEntityRecordEdits(\n        'postType',\n        postType,\n        postId\n    );\n} );\n</code></pre>\n<p>Note how the <code>getCurrentPostId</code> selector can be called just like any other function,<br />\n(it works even inside a regular non-registry selector) and we don&#8217;t need to pass the<br />\nregistry as argument. The registry binding happens automatically when registering the selector<br />\nwith a store.</p>\n<p><em>Parameters</em></p>\n<ul>\n<li><em>registrySelector</em> <code>( select:  ) =&gt; Selector</code>: Function receiving a registry <code>select</code> function and returning a state selector.</li>\n</ul>\n<p><em>Returns</em></p>\n<ul>\n<li><code>RegistrySelector&lt; Selector &gt;</code>: Registry selector that can be registered with a store.</li>\n</ul>\n<h3>createSelector</h3>\n<p>Creates a memoized selector that caches the computed values according to the array of &#8220;dependants&#8221; and the selector parameters, and recomputes the values only when any of them changes.</p>\n<p><em>Related</em></p>\n<ul>\n<li>The documentation for the <code>rememo</code> package from which the <code>createSelector</code> function is reexported.</li>\n</ul>\n<h3>dispatch</h3>\n<p>Given a store descriptor, returns an object of the store&#8217;s action creators. Calling an action creator will cause it to be dispatched, updating the state value accordingly.</p>\n<p>Note: Action creators returned by the dispatch will return a promise when they are called.</p>\n<p><em>Usage</em></p>\n<pre><code class=\"language-js\">import { dispatch } from '@wordpress/data';\nimport { store as myCustomStore } from 'my-custom-store';\n\ndispatch( myCustomStore ).setPrice( 'hammer', 9.75 );\n</code></pre>\n<p><em>Parameters</em></p>\n<ul>\n<li><em>storeNameOrDescriptor</em> <code>StoreNameOrDescriptor</code>: The store descriptor. The legacy calling convention of passing the store name is also supported.</li>\n</ul>\n<p><em>Returns</em></p>\n<ul>\n<li><code>DispatchReturn&lt; StoreNameOrDescriptor &gt;</code>: Object containing the action creators.</li>\n</ul>\n<h3>plugins</h3>\n<p>Object of available plugins to use with a registry.</p>\n<p><em>Related</em></p>\n<ul>\n<li><a href=\"#use\">use</a></li>\n</ul>\n<p><em>Type</em></p>\n<ul>\n<li><code>Object</code></li>\n</ul>\n<h3>register</h3>\n<p>Registers a standard <code>@wordpress/data</code> store descriptor.</p>\n<p><em>Usage</em></p>\n<pre><code class=\"language-js\">import { createReduxStore, register } from '@wordpress/data';\n\nconst store = createReduxStore( 'demo', {\n    reducer: ( state = 'OK' ) =&gt; state,\n    selectors: {\n        getValue: ( state ) =&gt; state,\n    },\n} );\nregister( store );\n</code></pre>\n<p><em>Parameters</em></p>\n<ul>\n<li><em>store</em> <code>StoreDescriptor</code>: Store descriptor.</li>\n</ul>\n<h3>registerGenericStore</h3>\n<blockquote><p>\n  <strong>Deprecated</strong> Use <code>register( storeDescriptor )</code> instead.\n</p></blockquote>\n<p>Registers a generic store instance.</p>\n<p><em>Parameters</em></p>\n<ul>\n<li><em>name</em> <code>string</code>: Store registry name.</li>\n<li><em>store</em> <code>Object</code>: Store instance (<code>{ getSelectors, getActions, subscribe }</code>).</li>\n</ul>\n<h3>registerStore</h3>\n<blockquote><p>\n  <strong>Deprecated</strong> Use <code>register</code> instead.\n</p></blockquote>\n<p>Registers a standard <code>@wordpress/data</code> store.</p>\n<p><em>Parameters</em></p>\n<ul>\n<li><em>storeName</em> <code>string</code>: Unique namespace identifier for the store.</li>\n<li><em>options</em> <code>Object</code>: Store description (reducer, actions, selectors, resolvers).</li>\n</ul>\n<p><em>Returns</em></p>\n<ul>\n<li><code>Object</code>: Registered store object.</li>\n</ul>\n<h3>RegistryConsumer</h3>\n<p>A custom react Context consumer exposing the provided <code>registry</code> to children components. Used along with the RegistryProvider.</p>\n<p>You can read more about the react context api here: <a href=\"https://react.dev/learn/passing-data-deeply-with-context#step-3-provide-the-context\">https://react.dev/learn/passing-data-deeply-with-context#step-3-provide-the-context</a></p>\n<p><em>Usage</em></p>\n<pre><code class=\"language-js\">import {\n  RegistryProvider,\n  RegistryConsumer,\n  createRegistry\n} from '@wordpress/data';\n\nconst registry = createRegistry( {} );\n\nconst App = ( { props } ) =&gt; {\n  return &lt;RegistryProvider value={ registry }&gt;\n    &lt;div&gt;Hello There&lt;/div&gt;\n    &lt;RegistryConsumer&gt;\n      { ( registry ) =&gt; (\n        &lt;ComponentUsingRegistry\n                { ...props }\n              registry={ registry }\n      ) }\n    &lt;/RegistryConsumer&gt;\n  &lt;/RegistryProvider&gt;\n}\n</code></pre>\n<h3>RegistryProvider</h3>\n<p>A custom Context provider for exposing the provided <code>registry</code> to children components via a consumer.</p>\n<p>See <a name=\"#RegistryConsumer\">RegistryConsumer</a> documentation for example.</p>\n<h3>resolveSelect</h3>\n<p>Given a store descriptor, returns an object containing the store&#8217;s selectors pre-bound to state so that you only need to supply additional arguments, and modified so that they return promises that resolve to their eventual values, after any resolvers have ran.</p>\n<p><em>Usage</em></p>\n<pre><code class=\"language-js\">import { resolveSelect } from '@wordpress/data';\nimport { store as myCustomStore } from 'my-custom-store';\n\nresolveSelect( myCustomStore ).getPrice( 'hammer' ).then( console.log );\n</code></pre>\n<p><em>Parameters</em></p>\n<ul>\n<li><em>storeNameOrDescriptor</em> <code>StoreDescriptor|string</code>: The store descriptor. The legacy calling convention of passing the store name is also supported.</li>\n</ul>\n<p><em>Returns</em></p>\n<ul>\n<li><code>Object</code>: Object containing the store&#8217;s promise-wrapped selectors.</li>\n</ul>\n<h3>select</h3>\n<p>Given a store descriptor, returns an object of the store&#8217;s selectors. The selector functions are been pre-bound to pass the current state automatically. As a consumer, you need only pass arguments of the selector, if applicable.</p>\n<p><em>Usage</em></p>\n<pre><code class=\"language-js\">import { select } from '@wordpress/data';\nimport { store as myCustomStore } from 'my-custom-store';\n\nselect( myCustomStore ).getPrice( 'hammer' );\n</code></pre>\n<p><em>Parameters</em></p>\n<ul>\n<li><em>storeNameOrDescriptor</em> <code>string | T</code>: The store descriptor. The legacy calling convention of passing the store name is also supported.</li>\n</ul>\n<p><em>Returns</em></p>\n<ul>\n<li><code>CurriedSelectorsOf&lt; T &gt;</code>: Object containing the store&#8217;s selectors.</li>\n</ul>\n<h3>subscribe</h3>\n<p>Given a listener function, the function will be called any time the state value of one of the registered stores has changed. If you specify the optional <code>storeNameOrDescriptor</code> parameter, the listener function will be called only on updates on that one specific registered store.</p>\n<p>This function returns an <code>unsubscribe</code> function used to stop the subscription.</p>\n<p><em>Usage</em></p>\n<pre><code class=\"language-js\">import { subscribe } from '@wordpress/data';\n\nconst unsubscribe = subscribe( () =&gt; {\n    // You could use this opportunity to test whether the derived result of a\n    // selector has subsequently changed as the result of a state update.\n} );\n\n// Later, if necessary...\nunsubscribe();\n</code></pre>\n<p><em>Parameters</em></p>\n<ul>\n<li><em>listener</em> <code>Function</code>: Callback function.</li>\n<li><em>storeNameOrDescriptor</em> <code>string|StoreDescriptor?</code>: Optional store name.</li>\n</ul>\n<h3>suspendSelect</h3>\n<p>Given a store descriptor, returns an object containing the store&#8217;s selectors pre-bound to state so that you only need to supply additional arguments, and modified so that they throw promises in case the selector is not resolved yet.</p>\n<p><em>Parameters</em></p>\n<ul>\n<li><em>storeNameOrDescriptor</em> <code>StoreDescriptor|string</code>: The store descriptor. The legacy calling convention of passing the store name is also supported.</li>\n</ul>\n<p><em>Returns</em></p>\n<ul>\n<li><code>Object</code>: Object containing the store&#8217;s suspense-wrapped selectors.</li>\n</ul>\n<h3>use</h3>\n<p>Extends a registry to inherit functionality provided by a given plugin. A plugin is an object with properties aligning to that of a registry, merged to extend the default registry behavior.</p>\n<p><em>Parameters</em></p>\n<ul>\n<li><em>plugin</em> <code>Object</code>: Plugin object.</li>\n</ul>\n<h3>useDispatch</h3>\n<p>A custom react hook returning the current registry dispatch actions creators.</p>\n<p>Note: The component using this hook must be within the context of a RegistryProvider.</p>\n<p><em>Usage</em></p>\n<p>This illustrates a pattern where you may need to retrieve dynamic data from<br />\nthe server via the <code>useSelect</code> hook to use in combination with the dispatch<br />\naction.</p>\n<pre><code class=\"language-jsx\">import { useCallback } from 'react';\nimport { useDispatch, useSelect } from '@wordpress/data';\nimport { store as myCustomStore } from 'my-custom-store';\n\nfunction Button( { onClick, children } ) {\n    return (\n        &lt;button type=\"button\" onClick={ onClick }&gt;\n            { children }\n        &lt;/button&gt;\n    );\n}\n\nconst SaleButton = ( { children } ) =&gt; {\n    const { stockNumber } = useSelect(\n        ( select ) =&gt; select( myCustomStore ).getStockNumber(),\n        []\n    );\n    const { startSale } = useDispatch( myCustomStore );\n    const onClick = useCallback( () =&gt; {\n        const discountPercent = stockNumber &gt; 50 ? 10 : 20;\n        startSale( discountPercent );\n    }, [ stockNumber ] );\n    return &lt;Button onClick={ onClick }&gt;{ children }&lt;/Button&gt;;\n};\n\n// Rendered somewhere in the application:\n//\n// &lt;SaleButton&gt;Start Sale!&lt;/SaleButton&gt;\n</code></pre>\n<p><em>Parameters</em></p>\n<ul>\n<li><em>storeNameOrDescriptor</em> <code>[StoreNameOrDescriptor]</code>: Optionally provide the name of the store or its descriptor from which to retrieve action creators. If not provided, the registry.dispatch function is returned instead.</li>\n</ul>\n<p><em>Returns</em></p>\n<ul>\n<li><code>UseDispatchReturn&lt;StoreNameOrDescriptor&gt;</code>: A custom react hook.</li>\n</ul>\n<h3>useRegistry</h3>\n<p>A custom react hook exposing the registry context for use.</p>\n<p>This exposes the <code>registry</code> value provided via the <a href=\"#RegistryProvider\">Registry Provider</a> to a component implementing this hook.</p>\n<p>It acts similarly to the <code>useContext</code> react hook.</p>\n<p>Note: Generally speaking, <code>useRegistry</code> is a low level hook that in most cases won&#8217;t be needed for implementation. Most interactions with the <code>@wordpress/data</code> API can be performed via the <code>useSelect</code> hook, or the <code>withSelect</code> and <code>withDispatch</code> higher order components.</p>\n<p><em>Usage</em></p>\n<pre><code class=\"language-js\">import { RegistryProvider, createRegistry, useRegistry } from '@wordpress/data';\n\nconst registry = createRegistry( {} );\n\nconst SomeChildUsingRegistry = ( props ) =&gt; {\n    const registry = useRegistry();\n    // ...logic implementing the registry in other react hooks.\n};\n\nconst ParentProvidingRegistry = ( props ) =&gt; {\n    return (\n        &lt;RegistryProvider value={ registry }&gt;\n            &lt;SomeChildUsingRegistry { ...props } /&gt;\n        &lt;/RegistryProvider&gt;\n    );\n};\n</code></pre>\n<p><em>Returns</em></p>\n<ul>\n<li><code>Function</code>: A custom react hook exposing the registry context value.</li>\n</ul>\n<h3>useSelect</h3>\n<p>Custom react hook for retrieving props from registered selectors.</p>\n<p>In general, this custom React hook follows the <a href=\"https://react.dev/reference/rules/rules-of-hooks\">rules of hooks</a>.</p>\n<p><em>Usage</em></p>\n<pre><code class=\"language-js\">import { useSelect } from '@wordpress/data';\nimport { store as myCustomStore } from 'my-custom-store';\n\nfunction HammerPriceDisplay( { currency } ) {\n    const price = useSelect(\n        ( select ) =&gt; {\n            return select( myCustomStore ).getPrice( 'hammer', currency );\n        },\n        [ currency ]\n    );\n    return new Intl.NumberFormat( 'en-US', {\n        style: 'currency',\n        currency,\n    } ).format( price );\n}\n\n// Rendered in the application:\n// &lt;HammerPriceDisplay currency=\"USD\" /&gt;\n</code></pre>\n<p>In the above example, when <code>HammerPriceDisplay</code> is rendered into an<br />\napplication, the price will be retrieved from the store state using the<br />\n<code>mapSelect</code> callback on <code>useSelect</code>. If the currency prop changes then<br />\nany price in the state for that currency is retrieved. If the currency prop<br />\ndoesn&#8217;t change and other props are passed in that do change, the price will<br />\nnot change because the dependency is just the currency.</p>\n<p>When data is only used in an event callback, the data should not be retrieved<br />\non render, so it may be useful to get the selectors function instead.</p>\n<p><strong>Don&#8217;t use <code>useSelect</code> this way when calling the selectors in the render<br />\nfunction because your component won&#8217;t re-render on a data change.</strong></p>\n<pre><code class=\"language-js\">import { useSelect } from '@wordpress/data';\nimport { store as myCustomStore } from 'my-custom-store';\n\nfunction Paste( { children } ) {\n    const { getSettings } = useSelect( myCustomStore );\n    function onPaste() {\n        // Do something with the settings.\n        const settings = getSettings();\n    }\n    return &lt;div onPaste={ onPaste }&gt;{ children }&lt;/div&gt;;\n}\n</code></pre>\n<p><em>Parameters</em></p>\n<ul>\n<li><em>mapSelect</em> <code>T</code>: Function called on every state change. The returned value is exposed to the component implementing this hook. The function receives the <code>registry.select</code> method on the first argument and the <code>registry</code> on the second argument. When a store key is passed, all selectors for the store will be returned. This is only meant for usage of these selectors in event callbacks, not for data needed to create the element tree.</li>\n<li><em>deps</em> <code>unknown[]</code>: If provided, this memoizes the mapSelect so the same <code>mapSelect</code> is invoked on every state change unless the dependencies change.</li>\n</ul>\n<p><em>Returns</em></p>\n<ul>\n<li><code>UseSelectReturn&lt;T&gt;</code>: A custom react hook.</li>\n</ul>\n<h3>useSuspenseSelect</h3>\n<p>A variant of the <code>useSelect</code> hook that has the same API, but is a compatible Suspense-enabled data source.</p>\n<p><em>Parameters</em></p>\n<ul>\n<li><em>mapSelect</em> <code>T</code>: Function called on every state change. The returned value is exposed to the component using this hook. The function receives the <code>registry.suspendSelect</code> method as the first argument and the <code>registry</code> as the second one.</li>\n<li><em>deps</em> <code>Array</code>: A dependency array used to memoize the <code>mapSelect</code> so that the same <code>mapSelect</code> is invoked on every state change unless the dependencies change.</li>\n</ul>\n<p><em>Returns</em></p>\n<ul>\n<li><code>ReturnType&lt;T&gt;</code>: Data object returned by the <code>mapSelect</code> function.</li>\n</ul>\n<h3>withDispatch</h3>\n<p>Higher-order component used to add dispatch props using registered action creators.</p>\n<p><em>Usage</em></p>\n<pre><code class=\"language-jsx\">function Button( { onClick, children } ) {\n    return (\n        &lt;button type=\"button\" onClick={ onClick }&gt;\n            { children }\n        &lt;/button&gt;\n    );\n}\n\nimport { withDispatch } from '@wordpress/data';\nimport { store as myCustomStore } from 'my-custom-store';\n\nconst SaleButton = withDispatch( ( dispatch, ownProps ) =&gt; {\n    const { startSale } = dispatch( myCustomStore );\n    const { discountPercent } = ownProps;\n\n    return {\n        onClick() {\n            startSale( discountPercent );\n        },\n    };\n} )( Button );\n\n// Rendered in the application:\n//\n// &lt;SaleButton discountPercent=\"20\"&gt;Start Sale!&lt;/SaleButton&gt;\n</code></pre>\n<p>In the majority of cases, it will be sufficient to use only two first params<br />\npassed to <code>mapDispatchToProps</code> as illustrated in the previous example.<br />\nHowever, there might be some very advanced use cases where using the<br />\n<code>registry</code> object might be used as a tool to optimize the performance of<br />\nyour component. Using <code>select</code> function from the registry might be useful<br />\nwhen you need to fetch some dynamic data from the store at the time when the<br />\nevent is fired, but at the same time, you never use it to render your<br />\ncomponent. In such scenario, you can avoid using the <code>withSelect</code> higher<br />\norder component to compute such prop, which might lead to unnecessary<br />\nre-renders of your component caused by its frequent value change.<br />\nKeep in mind, that <code>mapDispatchToProps</code> must return an object with functions<br />\nonly.</p>\n<pre><code class=\"language-jsx\">function Button( { onClick, children } ) {\n    return (\n        &lt;button type=\"button\" onClick={ onClick }&gt;\n            { children }\n        &lt;/button&gt;\n    );\n}\n\nimport { withDispatch } from '@wordpress/data';\nimport { store as myCustomStore } from 'my-custom-store';\n\nconst SaleButton = withDispatch( ( dispatch, ownProps, { select } ) =&gt; {\n    // Stock number changes frequently.\n    const { getStockNumber } = select( myCustomStore );\n    const { startSale } = dispatch( myCustomStore );\n    return {\n        onClick() {\n            const discountPercent = getStockNumber() &gt; 50 ? 10 : 20;\n            startSale( discountPercent );\n        },\n    };\n} )( Button );\n\n// Rendered in the application:\n//\n//  &lt;SaleButton&gt;Start Sale!&lt;/SaleButton&gt;\n</code></pre>\n<p><em>Note:</em> It is important that the <code>mapDispatchToProps</code> function always<br />\nreturns an object with the same keys. For example, it should not contain<br />\nconditions under which a different value would be returned.</p>\n<p><em>Parameters</em></p>\n<ul>\n<li><em>mapDispatchToProps</em> <code>Function</code>: A function of returning an object of prop names where value is a dispatch-bound action creator, or a function to be called with the component&#8217;s props and returning an action creator.</li>\n</ul>\n<p><em>Returns</em></p>\n<ul>\n<li><code>ComponentType</code>: Enhanced component with merged dispatcher props.</li>\n</ul>\n<h3>withRegistry</h3>\n<p>Higher-order component which renders the original component with the current registry context passed as its <code>registry</code> prop.</p>\n<p><em>Parameters</em></p>\n<ul>\n<li><em>OriginalComponent</em> <code>Component</code>: Original component.</li>\n</ul>\n<p><em>Returns</em></p>\n<ul>\n<li><code>Component</code>: Enhanced component.</li>\n</ul>\n<h3>withSelect</h3>\n<p>Higher-order component used to inject state-derived props using registered selectors.</p>\n<p><em>Usage</em></p>\n<pre><code class=\"language-js\">import { withSelect } from '@wordpress/data';\nimport { store as myCustomStore } from 'my-custom-store';\n\nfunction PriceDisplay( { price, currency } ) {\n    return new Intl.NumberFormat( 'en-US', {\n        style: 'currency',\n        currency,\n    } ).format( price );\n}\n\nconst HammerPriceDisplay = withSelect( ( select, ownProps ) =&gt; {\n    const { getPrice } = select( myCustomStore );\n    const { currency } = ownProps;\n\n    return {\n        price: getPrice( 'hammer', currency ),\n    };\n} )( PriceDisplay );\n\n// Rendered in the application:\n//\n//  &lt;HammerPriceDisplay currency=\"USD\" /&gt;\n</code></pre>\n<p>In the above example, when <code>HammerPriceDisplay</code> is rendered into an<br />\napplication, it will pass the price into the underlying <code>PriceDisplay</code><br />\ncomponent and update automatically if the price of a hammer ever changes in<br />\nthe store.</p>\n<p><em>Parameters</em></p>\n<ul>\n<li><em>mapSelectToProps</em> <code>Function</code>: Function called on every state change, expected to return object of props to merge with the component&#8217;s own props.</li>\n</ul>\n<p><em>Returns</em></p>\n<ul>\n<li><code>ComponentType</code>: Enhanced component with merged state data props.</li>\n</ul>\n<p><!-- END TOKEN(Autogenerated API docs) --></p>\n<h3>batch</h3>\n<p>As a response of <code>dispatch</code> calls, WordPress data based applications updates the connected components (Components using <code>useSelect</code> or <code>withSelect</code>). This update happens in two steps:</p>\n<ul>\n<li>The selectors are called with the update state.</li>\n<li>If the selectors return values that are different than the previous (strict equality), the component rerenders.</li>\n</ul>\n<p>As the application grows, this can become costful, so it&#8217;s important to ensure that we avoid running both these if possible. One of these situations happen when an interaction requires multiple consecutive <code>dispatch</code> calls in order to update the state properly. To avoid rerendering the components each time we call <code>dispatch</code>, we can wrap the sequential dispatch calls in <code>batch</code> which will ensure that the components only call selectors and rerender once at the end of the sequence.</p>\n<p><em>Usage</em></p>\n<pre><code class=\"language-js\">import { useRegistry } from '@wordpress/data';\n\nfunction Component() {\n    const registry = useRegistry();\n\n    function callback() {\n        // This will only rerender the components once.\n        registry.batch( () =&gt; {\n            registry.dispatch( someStore ).someAction();\n            registry.dispatch( someStore ).someOtherAction();\n        } );\n    }\n\n    return &lt;button onClick={ callback }&gt;Click me&lt;/button&gt;;\n}\n</code></pre>\n<h2>Selectors</h2>\n<p>The following selectors are available on the object returned by <code>wp.data.select( 'core' )</code>.</p>\n<p><em>Example</em></p>\n<pre><code class=\"language-js\">import { store as coreDataStore } from '@wordpress/core-data';\nimport { useSelect } from '@wordpress/data';\n\nfunction Component() {\n    const result = useSelect( ( select ) =&gt; {\n        const query = { per_page: 20 };\n        const selectorArgs = [ 'postType', 'page', query ];\n\n        return {\n            pages: select( coreDataStore ).getEntityRecords( ...selectorArgs ),\n            hasStartedResolution: select( coreDataStore ).hasStartedResolution(\n                'getEntityRecords', // _selectorName_\n                selectorArgs\n            ),\n            hasFinishedResolution: select(\n                coreDataStore\n            ).hasFinishedResolution( 'getEntityRecords', selectorArgs ),\n            isResolving: select( coreDataStore ).isResolving(\n                'getEntityRecords',\n                selectorArgs\n            ),\n        };\n    } );\n\n    if ( result.hasStartedResolution ) {\n        return &lt;&gt;Fetching data...&lt;/&gt;;\n    }\n\n    if ( result.isResolving ) {\n        return (\n            &lt;&gt;\n                {\n                    // show a spinner\n                 }\n            &lt;/&gt;\n        );\n    }\n\n    if ( result.hasFinishedResolution ) {\n        return (\n            &lt;&gt;\n                {\n                    // data is ready\n                 }\n            &lt;/&gt;\n        );\n    }\n}\n</code></pre>\n<h3>hasFinishedResolution</h3>\n<p>Returns true if resolution has completed for a given selector name, and arguments set.</p>\n<p><em>Parameters</em></p>\n<ul>\n<li><em>state</em> <code>State</code>: Data state.</li>\n<li><em>selectorName</em> <code>string</code>: Selector name.</li>\n<li><em>args</em> <code>unknown[]?</code>: Arguments passed to selector.</li>\n</ul>\n<p><em>Returns</em></p>\n<ul>\n<li><code>boolean</code>: Whether resolution has completed.</li>\n</ul>\n<h3>hasStartedResolution</h3>\n<p>Returns true if resolution has already been triggered for a given selector name, and arguments set.</p>\n<p><em>Parameters</em></p>\n<ul>\n<li><em>state</em> <code>State</code>: Data state.</li>\n<li><em>selectorName</em> <code>string</code>: Selector name.</li>\n<li><em>args</em> <code>unknown[]?</code>: Arguments passed to selector.</li>\n</ul>\n<p><em>Returns</em></p>\n<ul>\n<li><code>boolean</code>: Whether resolution has been triggered.</li>\n</ul>\n<h3>isResolving</h3>\n<p>Returns true if resolution has been triggered but has not yet completed for a given selector name, and arguments set.</p>\n<p><em>Parameters</em></p>\n<ul>\n<li><em>state</em> <code>State</code>: Data state.</li>\n<li><em>selectorName</em> <code>string</code>: Selector name.</li>\n<li><em>args</em> <code>unknown[]?</code>: Arguments passed to selector.</li>\n</ul>\n<p><em>Returns</em></p>\n<ul>\n<li><code>boolean</code>: Whether resolution is in progress.</li>\n</ul>\n<h3>Normalizing Selector Arguments</h3>\n<p>In specific circumstances it may be necessary to normalize the arguments passed to a given <em>call</em> of a selector/resolver pairing.</p>\n<p>Each resolver has <a href=\"https://github.com/WordPress/gutenberg/blob/e244388d8669618b76c966cc33d48df9156c2db6/packages/data/src/redux-store/metadata/reducer.ts#L39\">its resolution status cached in an internal state</a> where the <a href=\"https://github.com/WordPress/gutenberg/blob/e244388d8669618b76c966cc33d48df9156c2db6/packages/data/src/redux-store/metadata/utils.ts#L48\">key is the arguments supplied to the selector</a> at <em>call</em> time.</p>\n<p>For example for a selector with a single argument, the related resolver would generate a cache key of: <code>[ 123 ]</code>.</p>\n<p><a href=\"https://github.com/WordPress/gutenberg/blob/e244388d8669618b76c966cc33d48df9156c2db6/packages/data/src/redux-store/metadata/selectors.js#L22-L29\">This cache is used to determine the resolution status of a given resolver</a> which is used to <a href=\"https://github.com/WordPress/gutenberg/blob/e244388d8669618b76c966cc33d48df9156c2db6/packages/data/src/redux-store/index.js#L469-L474\">avoid unwanted additional invocations of resolvers</a> (which often undertake &#8220;expensive&#8221; operations such as network requests).</p>\n<p>As a result it&#8217;s important that arguments remain <em>consistent</em> when calling the selector. For example, by <em>default</em> these two calls will not be cached using the same key, even though they are likely identical:</p>\n<pre><code class=\"language-js\">// Arg as number\ngetSomeDataById( 123 );\n\n// Arg as string\ngetSomeDataById( '123' );\n</code></pre>\n<p>This is an opportunity to utilize the <code>__unstableNormalizeArgs</code> property to guarantee consistency by protecting callers from passing incorrect types.</p>\n<h4>Example</h4>\n<p>The <em>3rd</em> argument of the following selector is intended to be a <code>Number</code>:</p>\n<pre><code class=\"language-js\">const getItemsSelector = ( name, type, id ) =&gt; {\n    return state.items[ name ][ type ][ id ] || null;\n};\n</code></pre>\n<p>However, it is possible that the <code>id</code> parameter will be passed as a <code>String</code>. In this case, the <code>__unstableNormalizeArgs</code> method (property) can be defined on the <em>selector</em> to coerce the arguments to the desired type even if they are provided &#8220;incorrectly&#8221;:</p>\n<pre><code class=\"language-js\">// Define normalization method.\ngetItemsSelector.__unstableNormalizeArgs = ( args ) {\n    // \"id\" argument at the 2nd index\n    if (args[2] &amp;&amp; typeof args[2] === 'string' ) {\n        args[2] === Number(args[2]);\n    }\n\n    return args;\n}\n</code></pre>\n<p>With this in place the following code will behave consistently:</p>\n<pre><code class=\"language-js\">const getItemsSelector = ( name, type, id ) =&gt; {\n    // here 'id' is now guaranteed to be a number.\n    return state.items[ name ][ type ][ id ] || null;\n};\n\nconst getItemsResolver = ( name, type, id ) =&gt; {\n    // 'id' is also guaranteed to be a number in the resolver.\n    return {};\n};\n\nregistry.registerStore( 'store', {\n    // ...\n    selectors: {\n        getItems: getItemsSelector,\n    },\n    resolvers: {\n        getItems: getItemsResolver,\n    },\n} );\n\n// Call with correct number type.\nregistry.select( 'store' ).getItems( 'foo', 'bar', 54 );\n\n// Call with the wrong string type, **but** here we have avoided an\n// wanted resolver call because '54' is guaranteed to have been\n// coerced to a number by the `__unstableNormalizeArgs` method.\nregistry.select( 'store' ).getItems( 'foo', 'bar', '54' );\n</code></pre>\n<p>Ensuring consistency of arguments for a given selector call is <a href=\"https://github.com/WordPress/gutenberg/pull/52120\">an important optimization to help improve performance in the data layer</a>. However, this type of problem can be usually be avoided by ensuring selectors don&#8217;t use variable types for their arguments.</p>\n<h2>Going further</h2>\n<ul>\n<li><a href=\"https://unfoldingneurons.com/2020/what-is-wordpress-data/\">What is WordPress Data?</a></li>\n</ul>\n<h2>Contributing to this package</h2>\n<p>This is an individual package that&#8217;s part of the Gutenberg project. The project is organized as a monorepo. It&#8217;s made up of multiple self-contained software packages, each with a specific purpose. The packages in this monorepo are published to <a href=\"https://www.npmjs.com/\">npm</a> and used by <a href=\"https://make.wordpress.org/core/\">WordPress</a> as well as other software projects.</p>\n<p>To find out more about contributing to this package or Gutenberg as a whole, please read the project&#8217;s main <a href=\"https://github.com/WordPress/gutenberg/tree/HEAD/CONTRIBUTING.md\">contributor guide</a>.</p>\n",
        "protected": false
    },
    "author": 0,
    "featured_media": 0,
    "parent": 134521,
    "menu_order": 262,
    "template": "",
    "meta": {
        "footnotes": ""
    },
    "class_list": [
        "post-134546",
        "blocks-handbook",
        "type-blocks-handbook",
        "status-publish",
        "hentry",
        "type-handbook"
    ],
    "revision_note": "",
    "jetpack_sharing_enabled": true,
    "_links": {
        "self": [
            {
                "href": "https://developer.wordpress.org/wp-json/wp/v2/blocks-handbook/134546",
                "targetHints": {
                    "allow": [
                        "GET"
                    ]
                }
            }
        ],
        "collection": [
            {
                "href": "https://developer.wordpress.org/wp-json/wp/v2/blocks-handbook"
            }
        ],
        "about": [
            {
                "href": "https://developer.wordpress.org/wp-json/wp/v2/types/blocks-handbook"
            }
        ],
        "version-history": [
            {
                "count": 41,
                "href": "https://developer.wordpress.org/wp-json/wp/v2/blocks-handbook/134546/revisions"
            }
        ],
        "predecessor-version": [
            {
                "id": 156134,
                "href": "https://developer.wordpress.org/wp-json/wp/v2/blocks-handbook/134546/revisions/156134"
            }
        ],
        "up": [
            {
                "embeddable": true,
                "href": "https://developer.wordpress.org/wp-json/wp/v2/blocks-handbook/134521"
            }
        ],
        "wp:attachment": [
            {
                "href": "https://developer.wordpress.org/wp-json/wp/v2/media?parent=134546"
            }
        ],
        "curies": [
            {
                "name": "wp",
                "href": "https://api.w.org/{rel}",
                "templated": true
            }
        ]
    }
}