{
    "id": 134539,
    "date": "2021-03-09T08:38:22",
    "date_gmt": "2021-03-09T08:38:22",
    "guid": {
        "rendered": "https://developer.wordpress.org/block-editor/reference-guides/packages/packages-compose/"
    },
    "modified": "2024-10-30T16:55:29",
    "modified_gmt": "2024-10-30T16:55:29",
    "slug": "packages-compose",
    "status": "publish",
    "type": "blocks-handbook",
    "link": "https://developer.wordpress.org/block-editor/reference-guides/packages/packages-compose/",
    "title": {
        "rendered": "@wordpress/compose"
    },
    "content": {
        "rendered": "<p>The <code>compose</code> package is a collection of handy <a href=\"https://react.dev/reference/react/hooks\">Hooks</a> and <a href=\"https://legacy.reactjs.org/docs/higher-order-components.html\">Higher Order Components</a> (HOCs) you can use to wrap your WordPress components and provide some basic features like: state, instance id, pure&#8230;</p>\n<p>The <code>compose</code> function is inspired by <a href=\"https://lodash.com/docs/#flowRight\">flowRight</a> from Lodash and works the same way. It comes from functional programming, and allows you to compose any number of functions. You might also think of this as layering functions; <code>compose</code> will execute the last function first, then sequentially move back through the previous functions passing the result of each function upward.</p>\n<p>An example that illustrates it for two functions:</p>\n<pre><code class=\"language-js\">const compose = ( f, g ) =&gt; x\n    =&gt; f( g( x ) );\n</code></pre>\n<p>Here&#8217;s a simplified example of <strong>compose</strong> in use from Gutenberg&#8217;s <a href=\"https://github.com/WordPress/gutenberg/blob/HEAD/packages/editor/src/components/plugin-sidebar/index.js\"><code>PluginSidebar</code> component</a>:</p>\n<p>Using compose:</p>\n<pre><code class=\"language-js\">const applyWithSelect = withSelect( ( select, ownProps ) =&gt; {\n    return doSomething( select, ownProps );\n} );\nconst applyWithDispatch = withDispatch( ( dispatch, ownProps ) =&gt; {\n    return doSomethingElse( dispatch, ownProps );\n} );\n\nexport default compose(\n    withPluginContext,\n    applyWithSelect,\n    applyWithDispatch\n)( PluginSidebarMoreMenuItem );\n</code></pre>\n<p>Without <code>compose</code>, the code would look like this:</p>\n<pre><code class=\"language-js\">const applyWithSelect = withSelect( ( select, ownProps ) =&gt; {\n    return doSomething( select, ownProps );\n} );\nconst applyWithDispatch = withDispatch( ( dispatch, ownProps ) =&gt; {\n    return doSomethingElse( dispatch, ownProps );\n} );\n\nexport default withPluginContext(\n    applyWithSelect( applyWithDispatch( PluginSidebarMoreMenuItem ) )\n);\n</code></pre>\n<h2>Installation</h2>\n<p>Install the module</p>\n<pre><code class=\"language-bash\">npm install @wordpress/compose --save\n</code></pre>\n<p><em>This package assumes that your code will run in an <strong>ES2015+</strong> environment. If you&#8217;re using an environment that has limited or no support for such language features and APIs, you should include <a href=\"https://github.com/WordPress/gutenberg/tree/HEAD/packages/babel-preset-default#polyfill\">the polyfill shipped in <code>@wordpress/babel-preset-default</code></a> in your code.</em></p>\n<h2>API</h2>\n<p>For more details, you can refer to each Higher Order Component&#8217;s README file. <a href=\"https://github.com/WordPress/gutenberg/tree/HEAD/packages/compose/src\">Available components are located here.</a></p>\n<p><!-- START TOKEN(Autogenerated API docs) --></p>\n<h3>compose</h3>\n<p>Composes multiple higher-order components into a single higher-order component. Performs right-to-left function composition, where each successive invocation is supplied the return value of the previous.</p>\n<p>This is inspired by <code>lodash</code>&#8216;s <code>flowRight</code> function.</p>\n<p><em>Related</em></p>\n<ul>\n<li><a href=\"https://lodash.com/docs/4#flow-right\">https://lodash.com/docs/4#flow-right</a></li>\n</ul>\n<h3>createHigherOrderComponent</h3>\n<p>Given a function mapping a component to an enhanced component and modifier name, returns the enhanced component augmented with a generated displayName.</p>\n<p><em>Parameters</em></p>\n<ul>\n<li><em>mapComponent</em> <code>( Inner: TInner ) =&gt; TOuter</code>: Function mapping component to enhanced component.</li>\n<li><em>modifierName</em> <code>string</code>: Seed name from which to generated display name.</li>\n</ul>\n<p><em>Returns</em></p>\n<ul>\n<li>Component class with generated display name assigned.</li>\n</ul>\n<h3>debounce</h3>\n<p>A simplified and properly typed version of lodash&#8217;s <code>debounce</code>, that always uses timers instead of sometimes using rAF.</p>\n<p>Creates a debounced function that delays invoking <code>func</code> until after <code>wait</code> milliseconds have elapsed since the last time the debounced function was invoked. The debounced function comes with a <code>cancel</code> method to cancel delayed <code>func</code> invocations and a <code>flush</code> method to immediately invoke them. Provide <code>options</code> to indicate whether <code>func</code> should be invoked on the leading and/or trailing edge of the <code>wait</code> timeout. The <code>func</code> is invoked with the last arguments provided to the debounced function. Subsequent calls to the debounced function return the result of the last <code>func</code> invocation.</p>\n<p><strong>Note:</strong> If <code>leading</code> and <code>trailing</code> options are <code>true</code>, <code>func</code> is invoked on the trailing edge of the timeout only if the debounced function is invoked more than once during the <code>wait</code> timeout.</p>\n<p>If <code>wait</code> is <code>0</code> and <code>leading</code> is <code>false</code>, <code>func</code> invocation is deferred until the next tick, similar to <code>setTimeout</code> with a timeout of <code>0</code>.</p>\n<p><em>Parameters</em></p>\n<ul>\n<li><em>func</em> <code>Function</code>: The function to debounce.</li>\n<li><em>wait</em> <code>number</code>: The number of milliseconds to delay.</li>\n<li><em>options</em> <code>Partial&lt; DebounceOptions &gt;</code>: The options object.</li>\n<li><em>options.leading</em> <code>boolean</code>: Specify invoking on the leading edge of the timeout.</li>\n<li><em>options.maxWait</em> <code>number</code>: The maximum time <code>func</code> is allowed to be delayed before it&#8217;s invoked.</li>\n<li><em>options.trailing</em> <code>boolean</code>: Specify invoking on the trailing edge of the timeout.</li>\n</ul>\n<p><em>Returns</em></p>\n<ul>\n<li>Returns the new debounced function.</li>\n</ul>\n<h3>ifCondition</h3>\n<p>Higher-order component creator, creating a new component which renders if the given condition is satisfied or with the given optional prop name.</p>\n<p><em>Usage</em></p>\n<pre><code class=\"language-ts\">type Props = { foo: string };\nconst Component = ( props: Props ) =&gt; &lt;div&gt;{ props.foo }&lt;/div&gt;;\nconst ConditionalComponent = ifCondition( ( props: Props ) =&gt; props.foo.length !== 0 )( Component );\n&lt;ConditionalComponent foo=\"\" /&gt;; // =&gt; null\n&lt;ConditionalComponent foo=\"bar\" /&gt;; // =&gt; &lt;div&gt;bar&lt;/div&gt;;\n</code></pre>\n<p><em>Parameters</em></p>\n<ul>\n<li><em>predicate</em> <code>( props: Props ) =&gt; boolean</code>: Function to test condition.</li>\n</ul>\n<p><em>Returns</em></p>\n<ul>\n<li>Higher-order component.</li>\n</ul>\n<h3>observableMap</h3>\n<p>A constructor (factory) for <code>ObservableMap</code>, a map-like key/value data structure where the individual entries are observable: using the <code>subscribe</code> method, you can subscribe to updates for a particular keys. Each subscriber always observes one specific key and is not notified about any unrelated changes (for different keys) in the <code>ObservableMap</code>.</p>\n<p><em>Returns</em></p>\n<ul>\n<li><code>ObservableMap&lt; K, V &gt;</code>: A new instance of the <code>ObservableMap</code> type.</li>\n</ul>\n<h3>pipe</h3>\n<p>Composes multiple higher-order components into a single higher-order component. Performs left-to-right function composition, where each successive invocation is supplied the return value of the previous.</p>\n<p>This is inspired by <code>lodash</code>&#8216;s <code>flow</code> function.</p>\n<p><em>Related</em></p>\n<ul>\n<li><a href=\"https://lodash.com/docs/4#flow\">https://lodash.com/docs/4#flow</a></li>\n</ul>\n<h3>pure</h3>\n<blockquote><p>\n  <strong>Deprecated</strong> Use <code>memo</code> or <code>PureComponent</code> instead.\n</p></blockquote>\n<p>Given a component returns the enhanced component augmented with a component only re-rendering when its props/state change</p>\n<h3>throttle</h3>\n<p>A simplified and properly typed version of lodash&#8217;s <code>throttle</code>, that always uses timers instead of sometimes using rAF.</p>\n<p>Creates a throttled function that only invokes <code>func</code> at most once per every <code>wait</code> milliseconds. The throttled function comes with a <code>cancel</code> method to cancel delayed <code>func</code> invocations and a <code>flush</code> method to immediately invoke them. Provide <code>options</code> to indicate whether <code>func</code> should be invoked on the leading and/or trailing edge of the <code>wait</code> timeout. The <code>func</code> is invoked with the last arguments provided to the throttled function. Subsequent calls to the throttled function return the result of the last <code>func</code> invocation.</p>\n<p><strong>Note:</strong> If <code>leading</code> and <code>trailing</code> options are <code>true</code>, <code>func</code> is invoked on the trailing edge of the timeout only if the throttled function is invoked more than once during the <code>wait</code> timeout.</p>\n<p>If <code>wait</code> is <code>0</code> and <code>leading</code> is <code>false</code>, <code>func</code> invocation is deferred until the next tick, similar to <code>setTimeout</code> with a timeout of <code>0</code>.</p>\n<p><em>Parameters</em></p>\n<ul>\n<li><em>func</em> <code>Function</code>: The function to throttle.</li>\n<li><em>wait</em> <code>number</code>: The number of milliseconds to throttle invocations to.</li>\n<li><em>options</em> <code>Partial&lt; ThrottleOptions &gt;</code>: The options object.</li>\n<li><em>options.leading</em> <code>boolean</code>: Specify invoking on the leading edge of the timeout.</li>\n<li><em>options.trailing</em> <code>boolean</code>: Specify invoking on the trailing edge of the timeout.</li>\n</ul>\n<p><em>Returns</em></p>\n<ul>\n<li>Returns the new throttled function.</li>\n</ul>\n<h3>useAsyncList</h3>\n<p>React hook returns an array which items get asynchronously appended from a source array. This behavior is useful if we want to render a list of items asynchronously for performance reasons.</p>\n<p><em>Parameters</em></p>\n<ul>\n<li><em>list</em> <code>T[]</code>: Source array.</li>\n<li><em>config</em> <code>AsyncListConfig</code>: Configuration object.</li>\n</ul>\n<p><em>Returns</em></p>\n<ul>\n<li><code>T[]</code>: Async array.</li>\n</ul>\n<h3>useConstrainedTabbing</h3>\n<p>In Dialogs/modals, the tabbing must be constrained to the content of the wrapper element. This hook adds the behavior to the returned ref.</p>\n<p><em>Usage</em></p>\n<pre><code class=\"language-js\">import { useConstrainedTabbing } from '@wordpress/compose';\n\nconst ConstrainedTabbingExample = () =&gt; {\n    const constrainedTabbingRef = useConstrainedTabbing();\n    return (\n        &lt;div ref={ constrainedTabbingRef }&gt;\n            &lt;Button /&gt;\n            &lt;Button /&gt;\n        &lt;/div&gt;\n    );\n};\n</code></pre>\n<p><em>Returns</em></p>\n<ul>\n<li><code>import('react').RefCallback&lt;Element&gt;</code>: Element Ref.</li>\n</ul>\n<h3>useCopyOnClick</h3>\n<blockquote><p>\n  <strong>Deprecated</strong>\n</p></blockquote>\n<p>Copies the text to the clipboard when the element is clicked.</p>\n<p><em>Parameters</em></p>\n<ul>\n<li><em>ref</em> <code>import('react').RefObject&lt;string | Element | NodeListOf&lt;Element&gt;&gt;</code>: Reference with the element.</li>\n<li><em>text</em> <code>string|Function</code>: The text to copy.</li>\n<li><em>timeout</em> <code>[number]</code>: Optional timeout to reset the returned state. 4 seconds by default.</li>\n</ul>\n<p><em>Returns</em></p>\n<ul>\n<li><code>boolean</code>: Whether or not the text has been copied. Resets after the timeout.</li>\n</ul>\n<h3>useCopyToClipboard</h3>\n<p>Copies the given text to the clipboard when the element is clicked.</p>\n<p><em>Parameters</em></p>\n<ul>\n<li><em>text</em> <code>string | (() =&gt; string)</code>: The text to copy. Use a function if not already available and expensive to compute.</li>\n<li><em>onSuccess</em> <code>Function</code>: Called when to text is copied.</li>\n</ul>\n<p><em>Returns</em></p>\n<ul>\n<li><code>import('react').Ref&lt;TElementType&gt;</code>: A ref to assign to the target element.</li>\n</ul>\n<h3>useDebounce</h3>\n<p>Debounces a function similar to Lodash&#8217;s <code>debounce</code>. A new debounced function will be returned and any scheduled calls cancelled if any of the arguments change, including the function to debounce, so please wrap functions created on render in components in <code>useCallback</code>.</p>\n<p><em>Related</em></p>\n<ul>\n<li><a href=\"https://lodash.com/docs/4#debounce\">https://lodash.com/docs/4#debounce</a></li>\n</ul>\n<p><em>Parameters</em></p>\n<ul>\n<li><em>fn</em> <code>TFunc</code>: The function to debounce.</li>\n<li><em>wait</em> <code>[number]</code>: The number of milliseconds to delay.</li>\n<li><em>options</em> <code>[import('../../utils/debounce').DebounceOptions]</code>: The options object.</li>\n</ul>\n<p><em>Returns</em></p>\n<ul>\n<li><code>import('../../utils/debounce').DebouncedFunc&lt;TFunc&gt;</code>: Debounced function.</li>\n</ul>\n<h3>useDebouncedInput</h3>\n<p>Helper hook for input fields that need to debounce the value before using it.</p>\n<p><em>Parameters</em></p>\n<ul>\n<li><em>defaultValue</em> The default value to use.</li>\n</ul>\n<p><em>Returns</em></p>\n<ul>\n<li><code>[ string, ( value: string ) =&gt; void, string ]</code>: The input value, the setter and the debounced input value.</li>\n</ul>\n<h3>useDisabled</h3>\n<p>In some circumstances, such as block previews, all focusable DOM elements (input fields, links, buttons, etc.) need to be disabled. This hook adds the behavior to disable nested DOM elements to the returned ref.</p>\n<p>If you can, prefer the use of the inert HTML attribute.</p>\n<p><em>Usage</em></p>\n<pre><code class=\"language-js\">import { useDisabled } from '@wordpress/compose';\n\nconst DisabledExample = () =&gt; {\n    const disabledRef = useDisabled();\n    return (\n        &lt;div ref={ disabledRef }&gt;\n            &lt;a href=\"#\"&gt;This link will have tabindex set to -1&lt;/a&gt;\n            &lt;input\n                placeholder=\"This input will have the disabled attribute added to it.\"\n                type=\"text\"\n            /&gt;\n        &lt;/div&gt;\n    );\n};\n</code></pre>\n<p><em>Parameters</em></p>\n<ul>\n<li><em>config</em> <code>Object</code>: Configuration object.</li>\n<li><em>config.isDisabled</em> <code>boolean=</code>: Whether the element should be disabled.</li>\n</ul>\n<p><em>Returns</em></p>\n<ul>\n<li><code>import('react').RefCallback&lt;HTMLElement&gt;</code>: Element Ref.</li>\n</ul>\n<h3>useEvent</h3>\n<p>Creates a stable callback function that has access to the latest state and can be used within event handlers and effect callbacks. Throws when used in the render phase.</p>\n<p><em>Usage</em></p>\n<pre><code class=\"language-tsx\">function Component( props ) {\n    const onClick = useEvent( props.onClick );\n    useEffect( () =&gt; {\n        onClick();\n        // Won't trigger the effect again when props.onClick is updated.\n    }, [ onClick ] );\n    // Won't re-render Button when props.onClick is updated (if `Button` is\n    // wrapped in `React.memo`).\n    return &lt;Button onClick={ onClick } /&gt;;\n}\n</code></pre>\n<p><em>Parameters</em></p>\n<ul>\n<li><em>callback</em> <code>T</code>: The callback function to wrap.</li>\n</ul>\n<h3>useFocusableIframe</h3>\n<p>Dispatches a bubbling focus event when the iframe receives focus. Use <code>onFocus</code> as usual on the iframe or a parent element.</p>\n<p><em>Returns</em></p>\n<ul>\n<li><code>RefCallback&lt; HTMLIFrameElement &gt;</code>: Ref to pass to the iframe.</li>\n</ul>\n<h3>useFocusOnMount</h3>\n<p>Hook used to focus the first tabbable element on mount.</p>\n<p><em>Usage</em></p>\n<pre><code class=\"language-js\">import { useFocusOnMount } from '@wordpress/compose';\n\nconst WithFocusOnMount = () =&gt; {\n    const ref = useFocusOnMount();\n    return (\n        &lt;div ref={ ref }&gt;\n            &lt;Button /&gt;\n            &lt;Button /&gt;\n        &lt;/div&gt;\n    );\n};\n</code></pre>\n<p><em>Parameters</em></p>\n<ul>\n<li><em>focusOnMount</em> <code>boolean | 'firstElement'</code>: Focus on mount mode.</li>\n</ul>\n<p><em>Returns</em></p>\n<ul>\n<li><code>import('react').RefCallback&lt;HTMLElement&gt;</code>: Ref callback.</li>\n</ul>\n<h3>useFocusReturn</h3>\n<p>Adds the unmount behavior of returning focus to the element which had it previously as is expected for roles like menus or dialogs.</p>\n<p><em>Usage</em></p>\n<pre><code class=\"language-js\">import { useFocusReturn } from '@wordpress/compose';\n\nconst WithFocusReturn = () =&gt; {\n    const ref = useFocusReturn();\n    return (\n        &lt;div ref={ ref }&gt;\n            &lt;Button /&gt;\n            &lt;Button /&gt;\n        &lt;/div&gt;\n    );\n};\n</code></pre>\n<p><em>Parameters</em></p>\n<ul>\n<li><em>onFocusReturn</em> <code>[() =&gt; void]</code>: Overrides the default return behavior.</li>\n</ul>\n<p><em>Returns</em></p>\n<ul>\n<li><code>import('react').RefCallback&lt;HTMLElement&gt;</code>: Element Ref.</li>\n</ul>\n<h3>useInstanceId</h3>\n<p>Provides a unique instance ID.</p>\n<p><em>Parameters</em></p>\n<ul>\n<li><em>object</em> <code>object</code>: Object reference to create an id for.</li>\n<li><em>prefix</em> <code>[string]</code>: Prefix for the unique id.</li>\n<li><em>preferredId</em> <code>[string | number]</code>: Default ID to use.</li>\n</ul>\n<p><em>Returns</em></p>\n<ul>\n<li><code>string | number</code>: The unique instance id.</li>\n</ul>\n<h3>useIsomorphicLayoutEffect</h3>\n<p>Preferred over direct usage of <code>useLayoutEffect</code> when supporting server rendered components (SSR) because currently React throws a warning when using useLayoutEffect in that environment.</p>\n<h3>useKeyboardShortcut</h3>\n<p>Attach a keyboard shortcut handler.</p>\n<p><em>Related</em></p>\n<ul>\n<li><a href=\"https://craig.is/killing/mice#api.bind\">https://craig.is/killing/mice#api.bind</a> for information about the <code>callback</code> parameter.</li>\n</ul>\n<p><em>Parameters</em></p>\n<ul>\n<li><em>shortcuts</em> <code>string[]|string</code>: Keyboard Shortcuts.</li>\n<li><em>callback</em> <code>(e: import('mousetrap').ExtendedKeyboardEvent, combo: string) =&gt; void</code>: Shortcut callback.</li>\n<li><em>options</em> <code>WPKeyboardShortcutConfig</code>: Shortcut options.</li>\n</ul>\n<h3>useMediaQuery</h3>\n<p>Runs a media query and returns its value when it changes.</p>\n<p><em>Parameters</em></p>\n<ul>\n<li><em>query</em> <code>[string]</code>: Media Query.</li>\n</ul>\n<p><em>Returns</em></p>\n<ul>\n<li><code>boolean</code>: return value of the media query.</li>\n</ul>\n<h3>useMergeRefs</h3>\n<p>Merges refs into one ref callback.</p>\n<p>It also ensures that the merged ref callbacks are only called when they change (as a result of a <code>useCallback</code> dependency update) OR when the ref value changes, just as React does when passing a single ref callback to the component.</p>\n<p>As expected, if you pass a new function on every render, the ref callback will be called after every render.</p>\n<p>If you don&#8217;t wish a ref callback to be called after every render, wrap it with <code>useCallback( callback, dependencies )</code>. When a dependency changes, the old ref callback will be called with <code>null</code> and the new ref callback will be called with the same value.</p>\n<p>To make ref callbacks easier to use, you can also pass the result of <code>useRefEffect</code>, which makes cleanup easier by allowing you to return a cleanup function instead of handling <code>null</code>.</p>\n<p>It&#8217;s also possible to <em>disable</em> a ref (and its behaviour) by simply not passing the ref.</p>\n<pre><code class=\"language-jsx\">const ref = useRefEffect( ( node ) =&gt; {\n  node.addEventListener( ... );\n  return () =&gt; {\n    node.removeEventListener( ... );\n  };\n}, [ ...dependencies ] );\nconst otherRef = useRef();\nconst mergedRefs useMergeRefs( [\n  enabled &amp;&amp; ref,\n  otherRef,\n] );\nreturn &lt;div ref={ mergedRefs } /&gt;;\n</code></pre>\n<p><em>Parameters</em></p>\n<ul>\n<li><em>refs</em> <code>Array&lt;TRef&gt;</code>: The refs to be merged.</li>\n</ul>\n<p><em>Returns</em></p>\n<ul>\n<li><code>import('react').RefCallback&lt;TypeFromRef&lt;TRef&gt;&gt;</code>: The merged ref callback.</li>\n</ul>\n<h3>useObservableValue</h3>\n<p>React hook that lets you observe an entry in an <code>ObservableMap</code>. The hook returns the current value corresponding to the key, or <code>undefined</code> when there is no value stored. It also observes changes to the value and triggers an update of the calling component in case the value changes.</p>\n<p><em>Parameters</em></p>\n<ul>\n<li><em>map</em> <code>ObservableMap&lt; K, V &gt;</code>: The <code>ObservableMap</code> to observe.</li>\n<li><em>name</em> <code>K</code>: The map key to observe.</li>\n</ul>\n<p><em>Returns</em></p>\n<ul>\n<li><code>V | undefined</code>: The value corresponding to the map key requested.</li>\n</ul>\n<h3>usePrevious</h3>\n<p>Use something&#8217;s value from the previous render. Based on <a href=\"https://usehooks.com/usePrevious/\">https://usehooks.com/usePrevious/</a>.</p>\n<p><em>Parameters</em></p>\n<ul>\n<li><em>value</em> <code>T</code>: The value to track.</li>\n</ul>\n<p><em>Returns</em></p>\n<ul>\n<li><code>T | undefined</code>: The value from the previous render.</li>\n</ul>\n<h3>useReducedMotion</h3>\n<p>Hook returning whether the user has a preference for reduced motion.</p>\n<p><em>Returns</em></p>\n<ul>\n<li><code>boolean</code>: Reduced motion preference value.</li>\n</ul>\n<h3>useRefEffect</h3>\n<p>Effect-like ref callback. Just like with <code>useEffect</code>, this allows you to return a cleanup function to be run if the ref changes or one of the dependencies changes. The ref is provided as an argument to the callback functions. The main difference between this and <code>useEffect</code> is that the <code>useEffect</code> callback is not called when the ref changes, but this is. Pass the returned ref callback as the component&#8217;s ref and merge multiple refs with <code>useMergeRefs</code>.</p>\n<p>It&#8217;s worth noting that if the dependencies array is empty, there&#8217;s not strictly a need to clean up event handlers for example, because the node is to be removed. It <em>is</em> necessary if you add dependencies because the ref callback will be called multiple times for the same node.</p>\n<p><em>Parameters</em></p>\n<ul>\n<li><em>callback</em> <code>( node: TElement ) =&gt; ( () =&gt; void ) | void</code>: Callback with ref as argument.</li>\n<li><em>dependencies</em> <code>DependencyList</code>: Dependencies of the callback.</li>\n</ul>\n<p><em>Returns</em></p>\n<ul>\n<li><code>RefCallback&lt; TElement | null &gt;</code>: Ref callback.</li>\n</ul>\n<h3>useResizeObserver</h3>\n<p>Sets up a <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Resize_Observer_API\"><code>ResizeObserver</code></a> for an HTML or SVG element.</p>\n<p>Pass the returned setter as a callback ref to the React element you want to observe, or use it in layout effects for advanced use cases.</p>\n<p><em>Usage</em></p>\n<pre><code class=\"language-tsx\">const setElement = useResizeObserver(\n    ( resizeObserverEntries ) =&gt; console.log( resizeObserverEntries ),\n    { box: 'border-box' }\n);\n&lt;div ref={ setElement } /&gt;;\n\n// The setter can be used in other ways, for example:\nuseLayoutEffect( () =&gt; {\n    setElement( document.querySelector( `data-element-id=\"${ elementId }\"` ) );\n}, [ elementId ] );\n</code></pre>\n<p><em>Parameters</em></p>\n<ul>\n<li><em>callback</em> <code>ResizeObserverCallback</code>: The <code>ResizeObserver</code> callback &#8211; <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver/ResizeObserver#callback\">MDN docs</a>.</li>\n<li><em>options</em> <code>ResizeObserverOptions</code>: Options passed to <code>ResizeObserver.observe</code> when called &#8211; <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver/observe#options\">MDN docs</a>. Changes will be ignored.</li>\n</ul>\n<h3>useStateWithHistory</h3>\n<p>useState with undo/redo history.</p>\n<p><em>Parameters</em></p>\n<ul>\n<li><em>initialValue</em> <code>T</code>: Initial value.</li>\n</ul>\n<p><em>Returns</em></p>\n<ul>\n<li>Value, setValue, hasUndo, hasRedo, undo, redo.</li>\n</ul>\n<h3>useThrottle</h3>\n<p>Throttles a function similar to Lodash&#8217;s <code>throttle</code>. A new throttled function will be returned and any scheduled calls cancelled if any of the arguments change, including the function to throttle, so please wrap functions created on render in components in <code>useCallback</code>.</p>\n<p><em>Related</em></p>\n<ul>\n<li><a href=\"https://lodash.com/docs/4#throttle\">https://lodash.com/docs/4#throttle</a></li>\n</ul>\n<p><em>Parameters</em></p>\n<ul>\n<li><em>fn</em> <code>TFunc</code>: The function to throttle.</li>\n<li><em>wait</em> <code>[number]</code>: The number of milliseconds to throttle invocations to.</li>\n<li><em>options</em> <code>[import('../../utils/throttle').ThrottleOptions]</code>: The options object. See linked documentation for details.</li>\n</ul>\n<p><em>Returns</em></p>\n<ul>\n<li><code>import('../../utils/debounce').DebouncedFunc&lt;TFunc&gt;</code>: Throttled function.</li>\n</ul>\n<h3>useViewportMatch</h3>\n<p>Returns true if the viewport matches the given query, or false otherwise.</p>\n<p><em>Usage</em></p>\n<pre><code class=\"language-js\">useViewportMatch( 'huge', '&lt;' );\nuseViewportMatch( 'medium' );\n</code></pre>\n<p><em>Parameters</em></p>\n<ul>\n<li><em>breakpoint</em> <code>WPBreakpoint</code>: Breakpoint size name.</li>\n<li><em>operator</em> <code>[WPViewportOperator]</code>: Viewport operator.</li>\n</ul>\n<p><em>Returns</em></p>\n<ul>\n<li><code>boolean</code>: Whether viewport matches query.</li>\n</ul>\n<h3>useWarnOnChange</h3>\n<p>Hook that performs a shallow comparison between the preview value of an object and the new one, if there&#8217;s a difference, it prints it to the console. this is useful in performance related work, to check why a component re-renders.</p>\n<p><em>Usage</em></p>\n<pre><code class=\"language-jsx\">function MyComponent( props ) {\n    useWarnOnChange( props );\n\n    return 'Something';\n}\n</code></pre>\n<p><em>Parameters</em></p>\n<ul>\n<li><em>object</em> <code>object</code>: Object which changes to compare.</li>\n<li><em>prefix</em> <code>string</code>: Just a prefix to show when console logging.</li>\n</ul>\n<h3>withGlobalEvents</h3>\n<blockquote><p>\n  <strong>Deprecated</strong>\n</p></blockquote>\n<p>Higher-order component creator which, given an object of DOM event types and values corresponding to a callback function name on the component, will create or update a window event handler to invoke the callback when an event occurs. On behalf of the consuming developer, the higher-order component manages unbinding when the component unmounts, and binding at most a single event handler for the entire application.</p>\n<p><em>Parameters</em></p>\n<ul>\n<li><em>eventTypesToHandlers</em> <code>Record&lt;keyof GlobalEventHandlersEventMap, string&gt;</code>: Object with keys of DOM event type, the value a name of the function on the original component&#8217;s instance which handles the event.</li>\n</ul>\n<p><em>Returns</em></p>\n<ul>\n<li><code>any</code>: Higher-order component.</li>\n</ul>\n<h3>withInstanceId</h3>\n<p>A Higher Order Component used to provide a unique instance ID by component.</p>\n<h3>withSafeTimeout</h3>\n<p>A higher-order component used to provide and manage delayed function calls that ought to be bound to a component&#8217;s lifecycle.</p>\n<h3>withState</h3>\n<blockquote><p>\n  <strong>Deprecated</strong> Use <code>useState</code> instead.\n</p></blockquote>\n<p>A Higher Order Component used to provide and manage internal component state via props.</p>\n<p><em>Parameters</em></p>\n<ul>\n<li><em>initialState</em> <code>any</code>: Optional initial state of the component.</li>\n</ul>\n<p><em>Returns</em></p>\n<ul>\n<li><code>any</code>: A higher order component wrapper accepting a component that takes the state props + its own props + <code>setState</code> and returning a component that only accepts the own props.</li>\n</ul>\n<p><!-- END TOKEN(Autogenerated API docs) --></p>\n<h2>Contributing to this package</h2>\n<p>This is an individual package that&#8217;s part of the Gutenberg project. The project is organized as a monorepo. It&#8217;s made up of multiple self-contained software packages, each with a specific purpose. The packages in this monorepo are published to <a href=\"https://www.npmjs.com/\">npm</a> and used by <a href=\"https://make.wordpress.org/core/\">WordPress</a> as well as other software projects.</p>\n<p>To find out more about contributing to this package or Gutenberg as a whole, please read the project&#8217;s main <a href=\"https://github.com/WordPress/gutenberg/tree/HEAD/CONTRIBUTING.md\">contributor guide</a>.</p>\n",
        "protected": false
    },
    "author": 0,
    "featured_media": 0,
    "parent": 134521,
    "menu_order": 253,
    "template": "",
    "meta": {
        "footnotes": ""
    },
    "class_list": [
        "post-134539",
        "blocks-handbook",
        "type-blocks-handbook",
        "status-publish",
        "hentry",
        "type-handbook"
    ],
    "revision_note": "",
    "jetpack_sharing_enabled": true,
    "_links": {
        "self": [
            {
                "href": "https://developer.wordpress.org/wp-json/wp/v2/blocks-handbook/134539",
                "targetHints": {
                    "allow": [
                        "GET"
                    ]
                }
            }
        ],
        "collection": [
            {
                "href": "https://developer.wordpress.org/wp-json/wp/v2/blocks-handbook"
            }
        ],
        "about": [
            {
                "href": "https://developer.wordpress.org/wp-json/wp/v2/types/blocks-handbook"
            }
        ],
        "version-history": [
            {
                "count": 60,
                "href": "https://developer.wordpress.org/wp-json/wp/v2/blocks-handbook/134539/revisions"
            }
        ],
        "predecessor-version": [
            {
                "id": 155030,
                "href": "https://developer.wordpress.org/wp-json/wp/v2/blocks-handbook/134539/revisions/155030"
            }
        ],
        "up": [
            {
                "embeddable": true,
                "href": "https://developer.wordpress.org/wp-json/wp/v2/blocks-handbook/134521"
            }
        ],
        "wp:attachment": [
            {
                "href": "https://developer.wordpress.org/wp-json/wp/v2/media?parent=134539"
            }
        ],
        "curies": [
            {
                "name": "wp",
                "href": "https://api.w.org/{rel}",
                "templated": true
            }
        ]
    }
}