{
    "id": 18104,
    "date": "2025-06-12T00:42:39",
    "date_gmt": "2025-06-12T00:42:39",
    "guid": {
        "rendered": "https://make.wordpress.org/cli/handbook/commands-cookbook/"
    },
    "modified": "2025-07-01T13:10:10",
    "modified_gmt": "2025-07-01T13:10:10",
    "slug": "commands-cookbook",
    "status": "publish",
    "type": "handbook",
    "link": "https://make.wordpress.org/cli/handbook/guides/commands-cookbook/",
    "title": {
        "rendered": "Commands Cookbook"
    },
    "content": {
        "rendered": "<p>Creating your own custom <span tabindex='0' class='glossary-item-container'>WP-CLI<span class='glossary-item-hidden-content'><span class='glossary-item-header'>WP-CLI</span> <span class='glossary-item-description'>WP-CLI is the Command Line Interface for WordPress, used to do administrative and development tasks in a programmatic way. The project page is <a href=\"http://wp-cli.org/\">http://wp-cli.org/</a> <a href=\"https://make.wordpress.org/cli/\">https://make.wordpress.org/cli/</a></span></span></span> command can be easier than it looks \u2014 and you can use <code>wp scaffold package</code> (<a href=\"https://github.com/wp-cli/scaffold-package-command\">repo</a>) to dynamically generate everything but the command itself.</p>\n<h2>Overview</h2>\n<p>WP-CLI\u2019s goal is to offer a complete alternative to the WordPress admin; for any action you might want to perform in the WordPress admin, there should be an equivalent WP-CLI command. A <strong>command</strong> is an atomic unit of WP-CLI functionality. <code>wp plugin install</code> (<a href=\"https://developer.wordpress.org/cli/commands/plugin/install/\">doc</a>) is one such command, as is <code>wp plugin activate</code> (<a href=\"https://developer.wordpress.org/cli/commands/plugin/activate/\">doc</a>). Commands are useful to WordPress users because they can offer simple, precise interfaces for performing complex tasks.</p>\n<p><em>But</em>, the WordPress admin is a Swiss Army knife of infinite complexity. There\u2019s no way just this project could handle every use case. This is why WP-CLI includes a set of <a href=\"https://developer.wordpress.org/cli/commands/\">common internal commands</a>, while also offering a <a href=\"https://make.wordpress.org/cli/handbook/internal-api/\">rich internal API</a> for third-parties to write and register their own commands.</p>\n<p>WP-CLI commands can be <a href=\"https://wp-cli.org/package-index/\">distributed as standalone packages</a>, or bundled with WordPress plugins or themes. For the former, you can use <code>wp scaffold package</code> (<a href=\"https://github.com/wp-cli/scaffold-package-command\">repo</a>) to dynamically generate everything but the command itself.</p>\n<p>Packages are to WP-CLI as plugins are to WordPress. There are distinct differences in the approach you should take to creating a WP-CLI package.  While WP-CLI is an ever-growing alternative to /wp-admin it is important to note that you must first write your package to work with the WP-CLI internal <span tabindex='0' class='glossary-item-container'>API<span class='glossary-item-hidden-content'><span class='glossary-item-header'>API</span> <span class='glossary-item-description'>An API or Application Programming Interface is a software intermediary that allows programs to interact with each other and share data in limited, clearly defined ways.</span></span></span> before considering how you work with WordPress APIs.</p>\n<h4>Command types</h4>\n<p>Bundled commands:</p>\n<ul>\n<li>Usually cover functionality offered by a standard install WordPress. There are exceptions to this rule though, notably <code>wp search-replace</code> (<a href=\"https://developer.wordpress.org/cli/commands/search-replace/\">doc</a>).</li>\n<li>Do not depend on other components such as plugins, themes etc.</li>\n<li>Are maintained by the WP-CLI team.</li>\n</ul>\n<p>Third-party commands:</p>\n<ul>\n<li>Can be defined in plugins or themes.</li>\n<li>Can be easily scaffolded as standalone projects with <code>wp scaffold package</code> (<a href=\"https://github.com/wp-cli/scaffold-package-command\">repo</a>).</li>\n<li>Can be distributed independent of a <span tabindex='0' class='glossary-item-container'>plugin<span class='glossary-item-hidden-content'><span class='glossary-item-header'>Plugin</span> <span class='glossary-item-description'>A plugin is a piece of software containing a group of functions that can be added to a WordPress website. They can extend functionality or add new features to your WordPress websites. WordPress plugins are written in the PHP programming language and integrate seamlessly with WordPress. These can be free in the WordPress.org Plugin Directory https://wordpress.org/plugins/ or can be cost-based plugin from a third-party</span></span></span> or theme in the <a href=\"https://wp-cli.org/package-index/\">Package Index</a>.</li>\n</ul>\n<p>All commands:</p>\n<ul>\n<li>Follow the <a href=\"https://make.wordpress.org/cli/handbook/documentation-standards/\">documentation standards</a>.</li>\n</ul>\n<h2>Anatomy of a command</h2>\n<p>WP-CLI supports registering any callable class, function, or closure as a command. <code>WP_CLI::add_command()</code> (<a href=\"https://make.wordpress.org/cli/handbook/internal-api/wp-cli-add-command/\">doc</a>) is used for both internal and third-party command registration.</p>\n<p>The <strong>synopsis</strong> of a command defines which <strong>positional</strong> and <strong>associative</strong> arguments a command accepts. Let\u2019s take a look at the synopsis for <code>wp plugin install</code>:</p>\n<pre><code>$ wp plugin install\nusage: wp plugin install &lt;plugin|zip|url&gt;... [--version=&lt;version&gt;] [--force] [--activate] [--activate-network]\n</code></pre>\n<p>In this example, <code>&lt;plugin|zip|url&gt;...</code> is the accepted <strong>positional</strong> argument. In fact, <code>wp plugin install</code> accepts the same positional argument (the slug, ZIP, or <span tabindex='0' class='glossary-item-container'>URL<span class='glossary-item-hidden-content'><span class='glossary-item-header'>URL</span> <span class='glossary-item-description'>A specific web address of a website or web page on the Internet, such as a website\u2019s URL www.wordpress.org</span></span></span> of a plugin to install) multiple times. <code>[--version=&lt;version&gt;]</code> is one of the accepted <strong>associative</strong> arguments. It\u2019s used to denote the version of the plugin to install. Notice, too, the square brackets around the argument definition; square brackets mean the argument is optional.</p>\n<p>WP-CLI also has a <a href=\"https://make.wordpress.org/cli/handbook/config/\">series of global arguments</a> which work with all commands. For instance, including <code>--debug</code> means your command execution will display all <span tabindex='0' class='glossary-item-container'>PHP<span class='glossary-item-hidden-content'><span class='glossary-item-header'>PHP</span> <span class='glossary-item-description'>PHP (recursive acronym for PHP: Hypertext Preprocessor) is a widely-used open source general-purpose scripting language that is especially suited for web development and can be embedded into HTML. <a href=\"https://www.php.net/manual/en/preface.php\">https://www.php.net/manual/en/preface.php</a>.</span></span></span> errors, and add extra verbosity to the WP-CLI bootstrap process.</p>\n<h3>Required registration arguments</h3>\n<p>When registering a command, <code>WP_CLI::add_command()</code> requires two arguments:</p>\n<ol>\n<li><code>$name</code> is the command\u2019s name within WP-CLI\u2019s namespace (e.g. <code>plugin install</code> or <code>post list</code>).</li>\n<li><code>$callable</code> is the implementation of the command, as a callable class, function, or closure.</li>\n</ol>\n<p>In the following example, each instance of <code>wp foo</code> is functionally equivalent:</p>\n<pre><code>// 1. Command is a function\nfunction foo_command( $args ) {\n    WP_CLI::success( $args[0] );\n}\nWP_CLI::add_command( 'foo', 'foo_command' );\n\n// 2. Command is a closure\n$foo_command = function( $args ) {\n    WP_CLI::success( $args[0] );\n}\nWP_CLI::add_command( 'foo', $foo_command );\n\n// 3. Command is a method on a class\nclass Foo_Command {\n    public function __invoke( $args ) {\n        WP_CLI::success( $args[0] );\n    }\n}\nWP_CLI::add_command( 'foo', 'Foo_Command' );\n\n// 4. Command is a method on a class with constructor arguments\nclass Foo_Command {\n    protected $bar;\n    public function __construct( $bar ) {\n        $this-&gt;bar = $bar;\n    }\n    public function __invoke( $args ) {\n        WP_CLI::success( $this-&gt;bar . ':' . $args[0] );\n    }\n}\n$instance = new Foo_Command( 'Some text' );\nWP_CLI::add_command( 'foo', $instance );\n</code></pre>\n<p>Importantly, classes behave a bit differently than functions and closures in that:</p>\n<ul>\n<li>Any public methods on a class are registered as subcommands of the command. For instance, given the examples above, a method <code>bar()</code> on the class <code>Foo</code> would be registered as <code>wp foo bar</code>. But\u2026</li>\n<li><code>__invoke()</code> is treated as a magic method. If a class implements <code>__invoke()</code>, the command name will be registered to that method and no other methods of that class will be registered as commands.</li>\n</ul>\n<p><em>Note:</em> Historically, WP-CLI provided a base <code>WP_CLI_Command</code> class to extend, however extending this class is not required and will not change how your command behaves.</p>\n<p>All commands can be registered to their own top-level namespace (e.g. <code>wp foo</code>), or as subcommands to an existing namespace (e.g. <code>wp core foo</code>). For the latter, simply include the existing namespace as a part of the command definition.</p>\n<pre><code>class Foo_Command {\n    public function __invoke( $args ) {\n        WP_CLI::success( $args[0] );\n    }\n}\nWP_CLI::add_command( 'core foo', 'Foo_Command' );\n</code></pre>\n<h3>Quick and dirty execution</h3>\n<p>Writing a short script for a one-off task, and don\u2019t need to register it formally with <code>WP_CLI::add_command()</code>? <code>wp eval-file</code> is your ticket (<a href=\"https://developer.wordpress.org/cli/commands/eval-file/\">doc</a>).</p>\n<p>Given a <code>simple-command.php</code> file:</p>\n<pre><code>&lt;?php\nWP_CLI::success( \"The script has run!\" );\n</code></pre>\n<p>Your \u201ccommand\u201d can be run with <code>wp eval-file simple-command.php</code>. If the command doesn\u2019t have a dependency on WordPress, or WordPress isn\u2019t available, you can use the <code>--skip-wordpress</code> flag to avoid loading WordPress.</p>\n<h3>Optional registration arguments</h3>\n<p>WP-CLI supports two ways of registering optional arguments for your command: through the callable\u2019s PHPDoc, or passed as a third <code>$args</code> parameter to <code>WP_CLI::add_command()</code>.</p>\n<h4>Annotating with PHPDoc</h4>\n<p>A typical WP-CLI class looks like this:</p>\n<pre><code>&lt;?php\n/**\n * Implements example command.\n */\nclass Example_Command {\n\n    /**\n     * Prints a greeting.\n     *\n     * ## OPTIONS\n     *\n     * &lt;name&gt;\n     * : The name of the person to greet.\n     *\n     * [--type=&lt;type&gt;]\n     * : Whether or not to greet the person with success or error.\n     * ---\n     * default: success\n     * options:\n     *   - success\n     *   - error\n     * ---\n     *\n     * ## EXAMPLES\n     *\n     *     wp example hello Newman\n     *\n     * @when after_wp_load\n     */\n    function hello( $args, $assoc_args ) {\n        list( $name ) = $args;\n\n        // Print the message with type\n        $type = $assoc_args['type'];\n        WP_CLI::$type( \"Hello, $name!\" );\n    }\n}\n\nWP_CLI::add_command( 'example', 'Example_Command' );\n</code></pre>\n<p>This command\u2019s PHPDoc is interpreted in three ways:</p>\n<h4>Shortdesc</h4>\n<p>The shortdesc is the first line in the PHPDoc:</p>\n<pre><code>    /**\n     * Prints a greeting.\n</code></pre>\n<h4>Longdesc</h4>\n<p>The longdesc is middle part of the PHPDoc:</p>\n<pre><code>     * ## OPTIONS\n     *\n     * &lt;name&gt;\n     * : The name of the person to greet.\n     *\n     * [--type=&lt;type&gt;]\n     * : Whether or not to greet the person with success or error.\n     * ---\n     * default: success\n     * options:\n     *   - success\n     *   - error\n     * ---\n     *\n     * ## EXAMPLES\n     *\n     *     wp example hello Newman\n</code></pre>\n<p>Options defined in the longdesc are interpreted as the command\u2019s <strong>synopsis</strong>:</p>\n<ul>\n<li><code>&lt;name&gt;</code> is a required positional argument. Changing it to <code>&lt;name&gt;...</code> would mean the command can accept one or more positional arguments. Changing it to <code>[&lt;name&gt;]</code> would mean that the positional argument is optional and finally, changing it to <code>[&lt;name&gt;...]</code> would mean that the command can accept multiple optional positional arguments.</li>\n<li><code>[--type=&lt;type&gt;]</code> is an optional associative argument which defaults to \u2018success\u2019 and accepts either \u2018success\u2019 or \u2018error\u2019. Changing it to <code>[--error]</code> would change the argument to behave as an optional boolean flag.</li>\n<li><code>[--field[=&lt;value&gt;]]</code> allows an optional argument to be used with or without a value. An example of this would be using a global parameter like <code>--skip-plugins[=&lt;plugins&gt;]</code> which can either skip loading all plugins, or skip a comma-separated list of plugins. </li>\n</ul>\n<p><em>Note</em>: To accept arbitrary/unlimited number of optional associative arguments you would use the annotation <code>[--&lt;field&gt;=&lt;value&gt;]</code>.  So for example:</p>\n<pre><code>     * [--&lt;field&gt;=&lt;value&gt;]\n     * : Allow unlimited number of associative parameters.\n</code></pre>\n<p>A command\u2019s synopsis is used for validating the arguments, before passing them to the implementation.</p>\n<p>The longdesc is also displayed when calling the <code>help</code> command, for example, <code>wp help example hello</code>. Its syntax is <a href=\"http://michelf.ca/projects/php-markdown/extra/\">Markdown Extra</a> and here are a few more notes on how it\u2019s handled by WP-CLI:</p>\n<ul>\n<li>The longdesc is generally treated as a free-form text. The <code>OPTIONS</code> and <code>EXAMPLES</code> section names are not enforced, just common and recommended.</li>\n<li>Sections names (<code>## NAME</code>) are colorized and printed with zero indentation.</li>\n<li>Everything else is indented by 2 characters, option descriptions are further indented by additional 2 characters.</li>\n<li>Word-wrapping is a bit tricky. If you want to utilize as much space on each line as possible and don\u2019t get word-wrapping artifacts like one or two words on the next line, follow these rules:\n<ul>\n<li>Hard-wrap option descriptions at <strong>75 chars</strong> after the colon and a space.</li>\n<li>Hard-wrap everything else at <strong>90 chars</strong>.</li>\n</ul>\n</li>\n</ul>\n<p>For more details on how you should format your command docs, please see WP-CLI\u2019s <a href=\"https://make.wordpress.org/cli/handbook/documentation-standards/\">documentation standards</a>.</p>\n<h4>Docblock tags</h4>\n<p>This is the last section and it starts immediately after the longdesc:</p>\n<pre><code>     * @when after_wp_load\n     */\n</code></pre>\n<p>Here\u2019s the list of defined tags:</p>\n<p><strong>@subcommand</strong></p>\n<p>There are cases where you can\u2019t make the method name have the name of the subcommand. For example, you can\u2019t have a method named <code>list</code>, because <code>list</code> is a reserved keyword in PHP.</p>\n<p>That\u2019s when the <code>@subcommand</code> tag comes to the rescue:</p>\n<pre><code>    /**\n     * @subcommand list\n     */\n    function _list( $args, $assoc_args ) {\n        ...\n    }\n\n    /**\n     * @subcommand do-chores\n     */\n    function do_chores( $args, $assoc_args ) {\n        ...\n    }\n</code></pre>\n<p><strong>@alias</strong></p>\n<p>With the <code>@alias</code> tag, you can add another way of calling a subcommand. Example:</p>\n<pre><code>    /**\n     * @alias hi\n     */\n    function hello( $args, $assoc_args ) {\n        ...\n    }\n</code></pre>\n<pre><code>$ wp example hi Joe\nSuccess: Hello, Joe!\n</code></pre>\n<p><strong>@when</strong></p>\n<p>This is a special tag that tells WP-CLI when to execute the command. It supports <a href=\"https://make.wordpress.org/cli/handbook/internal-api/wp-cli-add-hook/\">all registered WP-CLI hooks</a>.</p>\n<p>Most WP-CLI commands execute after WordPress has loaded. The default behavior for a command is:</p>\n<pre><code>@when after_wp_load\n</code></pre>\n<p>To have a WP-CLI command run before WordPress loads, use:</p>\n<pre><code>@when before_wp_load\n</code></pre>\n<p>Do keep in mind most WP-CLI <span tabindex='0' class='glossary-item-container'>hooks<span class='glossary-item-hidden-content'><span class='glossary-item-header'>Hooks</span> <span class='glossary-item-description'>In WordPress theme and development, hooks are functions that can be applied to an action or a Filter in WordPress. Actions are functions performed when a certain event occurs in WordPress. Filters allow you to modify certain functions. Arguments used to hook both filters and actions look the same.</span></span></span> fire before WordPress is loaded. If your command is loaded from a plugin or theme, <code>@when</code> will be essentially ignored.</p>\n<p>It has no effect if the command using it is loaded from a plugin or a theme, because by that time WordPress itself will have already been loaded.</p>\n<h4>WP_CLI::add_command()\u2019s third $args parameter</h4>\n<p>Each of the configuration options supported by PHPDoc can instead be passed as the third argument in command registration:</p>\n<pre><code>$hello_command = function( $args, $assoc_args ) {\n    list( $name ) = $args;\n    $type = $assoc_args['type'];\n    WP_CLI::$type( \"Hello, $name!\" );\n    if ( isset( $assoc_args['honk'] ) ) {\n        WP_CLI::log( 'Honk!' );\n    }\n};\nWP_CLI::add_command( 'example hello', $hello_command, array(\n    'shortdesc' =&gt; 'Prints a greeting.',\n    'synopsis' =&gt; array(\n        array(\n            'type'        =&gt; 'positional',\n            'name'        =&gt; 'name',\n            'description' =&gt; 'The name of the person to greet.',\n            'optional'    =&gt; false,\n            'repeating'   =&gt; false,\n        ),\n        array(\n            'type'        =&gt; 'assoc',\n            'name'        =&gt; 'type',\n            'description' =&gt; 'Whether or not to greet the person with success or error.',\n            'optional'    =&gt; true,\n            'default'     =&gt; 'success',\n            'options'     =&gt; array( 'success', 'error' ),\n        ),\n        array(\n            'type'     =&gt; 'flag',\n            'name'     =&gt; 'honk',\n            'optional' =&gt; true,\n        ),\n    ),\n    'when' =&gt; 'after_wp_load',\n    'longdesc' =&gt;   '## EXAMPLES' . \"\\n\\n\" . 'wp example hello Newman',\n) );\n</code></pre>\n<p>Note that the <code>longdesc</code> attribute will be appended to the description of the options generated from the synopsis, so this argument is great for adding examples of usage. If there is no synopsis, the <code>longdesc</code> attribute will be used as is to provide a description.</p>\n<h3>Command internals</h3>\n<p>Now that you know how to register a command, the world is your oyster. Inside your callback, your command can do whatever it wants.</p>\n<h4>Accepting arguments</h4>\n<p>In order to handle runtime arguments, you have to add two parameters to your callable: <code>$args</code> and <code>$assoc_args</code>.</p>\n<pre><code>function hello( $args, $assoc_args ) {\n    /* Code goes here*/\n}\n</code></pre>\n<p><code>$args</code> variable will store all the positional arguments:</p>\n<pre><code>$ wp example hello Joe Doe\n</code></pre>\n<pre><code>WP_CLI::line( $args[0] ); // Joe\nWP_CLI::line( $args[1] ); // Doe\n</code></pre>\n<p><code>$assoc_args</code> variable will store all the arguments defined like <code>--key=value</code> or <code>--flag</code> or <code>--no-flag</code></p>\n<pre><code>$ wp example hello --name='Joe Doe' --verbose --no-option\n</code></pre>\n<pre><code>WP_CLI::line( $assoc_args['name'] ); // Joe Doe\nWP_CLI::line( $assoc_args['verbose'] ); // true\nWP_CLI::line( $assoc_args['option'] ); // false\n</code></pre>\n<p>Also, you can combine argument types:</p>\n<pre><code>$ wp example hello --name=Joe foo --verbose bar\n</code></pre>\n<pre><code>WP_CLI::line( $assoc_args['name'] ); // Joe\nWP_CLI::line( $assoc_args['verbose'] ); // true\nWP_CLI::line( $args[0] ); // foo\nWP_CLI::line( $args[1] ); // bar\n</code></pre>\n<h4>Effectively reusing WP-CLI internal APIs</h4>\n<p>As an example, say you were tasked with finding all unused themes on a <span tabindex='0' class='glossary-item-container'>multisite<span class='glossary-item-hidden-content'><span class='glossary-item-header'>Multisite</span> <span class='glossary-item-description'>Multisite is a WordPress feature which allows users to create a network of sites on a single WordPress installation. Available since WordPress version 3.0, Multisite is a continuation of WPMU or WordPress Multiuser project. WordPress MultiUser project was discontinued and its features were included into WordPress core.<a href=\"https://codex.wordpress.org/Create_A_Network\">https://codex.wordpress.org/Create_A_Network</a>.</span></span></span> network (<a href=\"https://github.com/wp-cli/wp-cli/issues/2523\">#2523</a>). If you had to perform this task manually through the WordPress admin, it would probably take hours, if not days, of effort. However, if you\u2019re familiar with writing WP-CLI commands, you could complete the task in 15 minutes or less.</p>\n<p>Here\u2019s what such a command looks like:</p>\n<pre><code>/**\n * Find unused themes on a multisite network.\n *\n * Iterates through all sites on a network to find themes which aren't enabled\n * on any site.\n */\n$find_unused_themes_command = function() {\n    $response = WP_CLI::launch_self( 'site list', array(), array( 'format' =&gt; 'json' ), false, true );\n    $sites = json_decode( $response-&gt;stdout );\n    $unused = array();\n    $used = array();\n    foreach( $sites as $site ) {\n        WP_CLI::log( \"Checking {$site-&gt;url} for unused themes...\" );\n        $response = WP_CLI::launch_self( 'theme list', array(), array( 'url' =&gt; $site-&gt;url, 'format' =&gt; 'json' ), false, true );\n        $themes = json_decode( $response-&gt;stdout );\n        foreach( $themes as $theme ) {\n            if ( 'no' == $theme-&gt;enabled &amp;&amp; 'inactive' == $theme-&gt;status &amp;&amp; ! in_array( $theme-&gt;name, $used ) ) {\n                $unused[ $theme-&gt;name ] = $theme;\n            } else {\n                if ( isset( $unused[ $theme-&gt;name ] ) ) {\n                    unset( $unused[ $theme-&gt;name ] );\n                }\n                $used[] = $theme-&gt;name;\n            }\n        }\n    }\n    WP_CLI\\Utils\\format_items( 'table', $unused, array( 'name', 'version' ) );\n};\nWP_CLI::add_command( 'find-unused-themes', $find_unused_themes_command, array(\n    'before_invoke' =&gt; function(){\n        if ( ! is_multisite() ) {\n            WP_CLI::error( 'This is not a multisite installation.' );\n        }\n    },\n) );\n</code></pre>\n<p>Let\u2019s run through the <a href=\"https://make.wordpress.org/cli/handbook/internal-api/\">internal APIs</a> this command uses to achieve its goal:</p>\n<ul>\n<li><code>WP_CLI::add_command()</code> (<a href=\"https://make.wordpress.org/cli/handbook/internal-api/wp-cli-add-command/\">doc</a>) is used to register a <code>find-unused-themes</code> command to the <code>$find_unused_themes_command</code> closure. The <code>before_invoke</code> argument makes it possible to verify the command is running on a multisite install, and error if not.</li>\n<li><code>WP_CLI::error()</code> (<a href=\"https://make.wordpress.org/cli/handbook/internal-api/wp-cli-error/\">doc</a>) renders a nicely formatted error message and exits.</li>\n<li><code>WP_CLI::launch_self()</code> (<a href=\"https://make.wordpress.org/cli/handbook/internal-api/wp-cli-launch-self/\">doc</a>) initially spawns a process to get a list of all sites, then is later used to get the list of themes for a given site.</li>\n<li><code>WP_CLI::log()</code> (<a href=\"https://make.wordpress.org/cli/handbook/internal-api/wp-cli-log/\">doc</a>) renders informational output to the end user.</li>\n<li><code>WP_CLI\\Utils\\format_items()</code> (<a href=\"https://make.wordpress.org/cli/handbook/internal-api/wp-cli-utils-format-items/\">doc</a>) renders the list of unused themes after the command has completed its discovery.</li>\n</ul>\n<h3>Help rendering</h3>\n<p>Your command\u2019s PHPDoc (or registered definition) is rendered using the <code>help</code> command. The output is ordered like this:</p>\n<ol>\n<li>Short description</li>\n<li>Synopsis</li>\n<li>Long description (OPTIONS, EXAMPLES etc.)</li>\n<li>Global parameters</li>\n</ol>\n<h2>Writing tests</h2>\n<p>WP-CLI makes use of a Behat-based testing framework, which you should use too. Behat is a great choice for your WP-CLI commands because:</p>\n<ul>\n<li>It\u2019s easy to write new tests, which means they\u2019ll actually get written.</li>\n<li>The tests interface with your command in the same manner as your users interface with your command.</li>\n</ul>\n<p>Behat tests live in the <code>features/</code> directory of your project. Here\u2019s an example from <code>features/cli-info.feature</code>:</p>\n<pre><code>Feature: Review CLI information\n\n  Scenario: Get the path to the packages directory\n    Given an empty directory\n\n    When I run `wp cli info --format=json`\n    Then STDOUT should be JSON containing:\n      \"\"\"\n      {\"wp_cli_packages_dir_path\":\"/tmp/wp-cli-home/.wp-cli/packages/\"}\n      \"\"\"\n\n    When I run `WP_CLI_PACKAGES_DIR=/tmp/packages wp cli info --format=json`\n    Then STDOUT should be JSON containing:\n      \"\"\"\n      {\"wp_cli_packages_dir_path\":\"/tmp/packages/\"}\n      \"\"\"\n</code></pre>\n<p>Functional tests typically follow this pattern:</p>\n<ul>\n<li><strong>Given</strong> some background,</li>\n<li><strong>When</strong> a user performs a specific action,</li>\n<li><strong>Then</strong> the end result should be X (and Y and Z).</li>\n</ul>\n<p>Convinced? Head on over to <a href=\"https://github.com/wp-cli/scaffold-package-command\">wp-cli/scaffold-package-command</a> to get started.</p>\n<h2>Distribution</h2>\n<p>Now that you\u2019ve produce a command you\u2019re proud of, it\u2019s time to share it with the world. There are two common ways of doing so.</p>\n<h3>Include in a plugin or theme</h3>\n<p>One way to share WP-CLI commands is by packaging them in your plugin or theme. Many people do so by conditionally loading (and registering) the command based on the presence of the <code>WP_CLI</code> constant.</p>\n<pre><code>if ( defined( 'WP_CLI' ) &amp;&amp; WP_CLI ) {\n    require_once dirname( __FILE__ ) . '/inc/class-plugin-cli-command.php';\n}\n</code></pre>\n<h3>Distribute as a stand-alone command</h3>\n<p>Standalone WP-CLI commands can be installed from any git repository, ZIP file or folder. The only technical requirement is to include a valid composer.<span tabindex='0' class='glossary-item-container'>json<span class='glossary-item-hidden-content'><span class='glossary-item-header'>JSON</span> <span class='glossary-item-description'>JSON, or JavaScript Object Notation, is a minimal, readable format for structuring data. It is used primarily to transmit data between a server and web application, as an alternative to XML.</span></span></span> file with an autoload declaration. We recommended including <code>\"type\": \"wp-cli-package\"</code> to distinguish your project explicitly as a WP-CLI package.</p>\n<p>Here\u2019s a full composer.json example from the server command:</p>\n<pre><code><br>{\n    \"name\": \"wp-cli/server-command\",\n    \"description\": \"Start a development server for WordPress\",\n    \"type\": \"wp-cli-package\",\n    \"homepage\": \"https://github.com/wp-cli/server-command\",\n    \"license\": \"MIT\",\n    \"authors\": [\n        {\n                \"name\": \"Package Maintainer\",\n                \"email\": \"packagemaintainer@homepage.com\",\n                \"homepage\": \"https://www.homepage.com\"\n            }\n        ],\n    \"require\": {\n        \"php\": \"&gt;=5.3.29\"\n    },\n    \"autoload\": {\n        \"files\": [ \"command.php\" ]\n    }\n}\n</code></pre>\n<p>Note the <code>autoload</code> declaration, which loads <code>command.php</code>.</p>\n<p>Once you\u2019ve added a valid composer.json file to your project repository, WP-CLI users can pull it in via the package manager from the location you opted to store it in. Here\u2019s a few examples of storage locations and the corresponding syntax of installing it via the package manager:</p>\n<h4><span tabindex='0' class='glossary-item-container'>Git<span class='glossary-item-hidden-content'><span class='glossary-item-header'>Git</span> <span class='glossary-item-description'>Git is a free and open source distributed version control system designed to handle everything from small to very large projects with speed and efficiency. Git is easy to learn and has a tiny footprint with lightning fast performance. Most modern plugin and theme development is being done with this version control system. <a href=\"https://git-scm.com/\">https://git-scm.com/</a>.</span></span></span> repository</h4>\n<p>To install a package that is found in a git repository, you can provide either the <span tabindex='0' class='glossary-item-container'>HTTPS<span class='glossary-item-hidden-content'><span class='glossary-item-header'>HTTPS</span> <span class='glossary-item-description'>HTTPS is an acronym for Hyper Text Transfer Protocol Secure. HTTPS  is the secure version of HTTP, the protocol over which data is sent between your browser and the website that you are connected to. The 'S' at the end of HTTPS stands for 'Secure'. It means all communications between your browser and the website are encrypted. This is especially helpful for protecting sensitive data like banking information.</span></span></span> or the <span tabindex='0' class='glossary-item-container'>SSH<span class='glossary-item-hidden-content'><span class='glossary-item-header'>SSH</span> <span class='glossary-item-description'>Secure SHell - a protocol for securely connecting to a remote system in addition to or in place of a password.</span></span></span> link to the git repository to the <code>package install</code> command.</p>\n<pre><code># Installing the package using an HTTPS link\n$ wp package install https://github.com/wp-cli/server-command.git\n\n# Installing the package using an SSH link\n$ wp package install git@github.com:wp-cli/server-command.git\n</code></pre>\n<h4>ZIP file</h4>\n<p>You can install a package from a ZIP file by providing the path to that file to the <code>wp package install</code> command.</p>\n<pre><code># Installing the package using a ZIP file\n$ wp package install ~/Downloads/server-command-main.zip\n</code></pre>\n<nav class='o2-post-footer-actions'><ul class='o2-post-footer-action-row'></ul><div class='o2-post-footer-action-likes'></div><ul class='o2-post-footer-action-row'></ul></nav>",
        "protected": false
    },
    "author": 368236,
    "featured_media": 0,
    "parent": 18370,
    "menu_order": 0,
    "template": "",
    "meta": {
        "jetpack_post_was_ever_published": false,
        "footnotes": ""
    },
    "class_list": [
        "post-18104",
        "handbook",
        "type-handbook",
        "status-publish",
        "hentry",
        "author-swissspidy"
    ],
    "revision_note": "",
    "jetpack_sharing_enabled": true,
    "_links": {
        "self": [
            {
                "href": "https://make.wordpress.org/cli/wp-json/wp/v2/handbook/18104",
                "targetHints": {
                    "allow": [
                        "GET"
                    ]
                }
            }
        ],
        "collection": [
            {
                "href": "https://make.wordpress.org/cli/wp-json/wp/v2/handbook"
            }
        ],
        "about": [
            {
                "href": "https://make.wordpress.org/cli/wp-json/wp/v2/types/handbook"
            }
        ],
        "author": [
            {
                "embeddable": true,
                "href": "https://make.wordpress.org/cli/wp-json/wp/v2/users/368236"
            }
        ],
        "version-history": [
            {
                "count": 1,
                "href": "https://make.wordpress.org/cli/wp-json/wp/v2/handbook/18104/revisions"
            }
        ],
        "predecessor-version": [
            {
                "id": 18361,
                "href": "https://make.wordpress.org/cli/wp-json/wp/v2/handbook/18104/revisions/18361"
            }
        ],
        "up": [
            {
                "embeddable": true,
                "href": "https://make.wordpress.org/cli/wp-json/wp/v2/handbook/18370"
            }
        ],
        "wp:attachment": [
            {
                "href": "https://make.wordpress.org/cli/wp-json/wp/v2/media?parent=18104"
            }
        ],
        "curies": [
            {
                "name": "wp",
                "href": "https://api.w.org/{rel}",
                "templated": true
            }
        ]
    }
}